//
//  Mocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird on 8/21/19.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import MockingbirdTestsHost
import CoreAudio
import CoreData
import CoreFoundation
import CoreImage
import CoreML
import CoreText
import Foundation
import ObjectiveC
import class CoreFoundation.CFArray
import enum CoreText.CTFontUIFontType

fileprivate class Synchronized<T> {
  private var internalValue: T
  fileprivate var value: T {
    get {
      lock.wait()
      defer { lock.signal() }
      return internalValue
    }

    set {
      lock.wait()
      defer { lock.signal() }
      internalValue = newValue
    }
  }
  private let lock = DispatchSemaphore(value: 1)

  fileprivate init(_ value: T) {
    self.internalValue = value
  }

  fileprivate func update(_ block: (inout T) throws -> Void) rethrows {
    lock.wait()
    defer { lock.signal() }
    try block(&internalValue)
  }
}

fileprivate var genericTypesStaticMocks = Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked AssociatedTypeGenericImplementer

public final class AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, Mockingbird.Mock where S.Element == EquatableType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(S.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeGenericImplementerMock, rhs: AssociatedTypeGenericImplementerMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `methodUsingEquatableType(equatable:)`

  public override func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public override func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType",
                                            arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>()
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<EquatableType>()
  }

  // MARK: Mockable `methodUsingHashableType(hashable:)`

  public override func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Stubbable<(HashableType) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`hashable`), as: HashableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(HashableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`hashable`), as: HashableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked AssociatedTypeImplementer

public final class AssociatedTypeImplementerMock: MockingbirdTestsHost.AssociatedTypeImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerMock, rhs: AssociatedTypeImplementerMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(object:)`

  public override func request<T: AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> Void, Void>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked AssociatedTypeImplementerProtocol

public final class AssociatedTypeImplementerProtocolMock: MockingbirdTestsHost.AssociatedTypeImplementerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerProtocolMock, rhs: AssociatedTypeImplementerProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> Void, Void>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType",
                                            arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<T.HashableType>()
  }

  // MARK: Mockable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType",
                                            arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: T.self)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<T.HashableType>()
  }
}

// MARK: - Mocked AssociatedTypeProtocol

public final class AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>: MockingbirdTestsHost.AssociatedTypeProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(HashableType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeProtocolMock, rhs: AssociatedTypeProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType",
                                            arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>()
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`equatable`), as: EquatableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<EquatableType>()
  }

  // MARK: Mockable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Stubbable<(HashableType) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`hashable`), as: HashableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(HashableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`hashable`), as: HashableType.self)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `childClassVariable`

  override public class var childClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childClassVariable`

  public class func getChildClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childClassVariable`

  public class func getChildClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childComputedInstanceVariable`

  override public var childComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ChildMock, rhs: ChildMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    ChildMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `childParameterizedClassMethod(param1:_:)`

  public override static func childParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public override func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childTrivialClassMethod()`

  public override static func childTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public override func childTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `childInstanceVariable`

  public var childInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childInstanceVariable`

  public func getChildInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childInstanceVariable`

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childPrivateSetterInstanceVariable`

  public var childPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childPrivateSetterStaticVariable`

  public class var childPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childStaticVariable`

  public class var childStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childStaticVariable`

  public class func getChildStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childStaticVariable`

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ChildProtocolMock, rhs: ChildProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    ChildProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked ExtendableProtocol

public final class ExtendableProtocolMock: MockingbirdTestsHost.ExtendableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `anotherExtendedVariable`

  public var anotherExtendedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `anotherExtendedVariable`

  public func getAnotherExtendedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setAnotherExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `anotherExtendedVariable`

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setAnotherExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `baseVariable`

  public var baseVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `extendedVariable`

  public var extendedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `extendedVariable`

  public func getExtendedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `extendedVariable`

  public func getExtendedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ExtendableProtocolMock, rhs: ExtendableProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: Bool) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param1`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param1`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: GrandparentMock, rhs: GrandparentMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    GrandparentMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: GrandparentProtocolMock, rhs: GrandparentProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked InoutClass

public final class InoutClassMock: MockingbirdTestsHost.InoutClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutClassMock, rhs: InoutClassMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    InoutClassMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `parameterizedMethod(object:)`

  public override func parameterizedMethod(object: inout String) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(inout String) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: String.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(inout String) -> Void, Void>()
  }

  // MARK: Verifiable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: String.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked InoutProtocol

public final class InoutProtocolMock: MockingbirdTestsHost.InoutProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutProtocolMock, rhs: InoutProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    InoutProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: inout String) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void",
                                            arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(inout String) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: String.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(inout String) -> Void, Void>()
  }

  // MARK: Verifiable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(`object`), as: String.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked NonExtendableClass

public final class NonExtendableClassMock: MockingbirdTestsHost.NonExtendableClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `baseVariable`

  override public var baseVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: NonExtendableClassMock, rhs: NonExtendableClassMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `trivialBaseMethod()`

  public override func trivialBaseMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ParentMock, rhs: ParentMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    ParentMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  private var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher.create(from: resolve(newValue), as: Bool.self)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ParentProtocolMock, rhs: ParentProtocolMock) -> Bool {
    return true
  }

  public init(__file: StaticString = #file, __line: UInt = #line) {
    let sourceLocation = Mockingbird.SourceLocation(__file, __line)
    self.stubbingContext.sourceLocation = sourceLocation
    ParentProtocolMock.staticMock.stubbingContext.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool",
                                            arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [
      Mockingbird.ArgumentMatcher.create(from: resolve(`param1`), as: Bool.self),
      Mockingbird.ArgumentMatcher.create(from: resolve(`param2`), as: Int.self)
    ]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                            arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void",
                                            arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}