//
//  Mocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird v0.3.0.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import MockingbirdTestsHost
import CoreAudio
import CoreData
import CoreFoundation
import CoreImage
import CoreML
import CoreText
import Foundation
import ObjectiveC
import class CoreFoundation.CFArray
import enum CoreText.CTFontUIFontType

private class Synchronized<T> {
  private var internalValue: T
  fileprivate var value: T {
    get {
      lock.wait()
      defer { lock.signal() }
      return internalValue
    }

    set {
      lock.wait()
      defer { lock.signal() }
      internalValue = newValue
    }
  }
  private let lock = DispatchSemaphore(value: 1)

  fileprivate init(_ value: T) {
    self.internalValue = value
  }

  fileprivate func update(_ block: (inout T) throws -> Void) rethrows {
    lock.wait()
    defer { lock.signal() }
    try block(&internalValue)
  }
}

private var genericTypesStaticMocks = Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked ArgumentMatchingProtocol

public final class ArgumentMatchingProtocolMock: MockingbirdTestsHost.ArgumentMatchingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArgumentMatchingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ArgumentMatchingProtocolMock, rhs: ArgumentMatchingProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: MockingbirdTestsHost.StructType?, optionalClassType: MockingbirdTestsHost.ClassType?, optionalEnumType: MockingbirdTestsHost.EnumType?, optionalStringType: String?, optionalBoolType: Bool?, optionalMetaType: ClassType.Type?, optionalAnyType: Any?, optionalAnyObjectType: AnyObject?) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalStructType`), Mockingbird.ArgumentMatcher(`optionalClassType`), Mockingbird.ArgumentMatcher(`optionalEnumType`), Mockingbird.ArgumentMatcher(`optionalStringType`), Mockingbird.ArgumentMatcher(`optionalBoolType`), Mockingbird.ArgumentMatcher(`optionalMetaType`), Mockingbird.ArgumentMatcher(`optionalAnyType`), Mockingbird.ArgumentMatcher(`optionalAnyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool {
      return concreteImplementation(`optionalStructType`, `optionalClassType`, `optionalEnumType`, `optionalStringType`, `optionalBoolType`, `optionalMetaType`, `optionalAnyType`, `optionalAnyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: @escaping @autoclosure () -> MockingbirdTestsHost.StructType?, optionalClassType: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType?, optionalEnumType: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType?, optionalStringType: @escaping @autoclosure () -> String?, optionalBoolType: @escaping @autoclosure () -> Bool?, optionalMetaType: @escaping @autoclosure () -> ClassType.Type?, optionalAnyType: @escaping @autoclosure () -> Any?, optionalAnyObjectType: @escaping @autoclosure () -> AnyObject?) -> Mockingbird.Stubbable<(MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`optionalStructType`), Mockingbird.resolve(`optionalClassType`), Mockingbird.resolve(`optionalEnumType`), Mockingbird.resolve(`optionalStringType`), Mockingbird.resolve(`optionalBoolType`), Mockingbird.resolve(`optionalMetaType`), Mockingbird.resolve(`optionalAnyType`), Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: @escaping @autoclosure () -> MockingbirdTestsHost.StructType?, optionalClassType: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType?, optionalEnumType: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType?, optionalStringType: @escaping @autoclosure () -> String?, optionalBoolType: @escaping @autoclosure () -> Bool?, optionalMetaType: @escaping @autoclosure () -> ClassType.Type?, optionalAnyType: @escaping @autoclosure () -> Any?, optionalAnyObjectType: @escaping @autoclosure () -> AnyObject?) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`optionalStructType`), Mockingbird.resolve(`optionalClassType`), Mockingbird.resolve(`optionalEnumType`), Mockingbird.resolve(`optionalStringType`), Mockingbird.resolve(`optionalBoolType`), Mockingbird.resolve(`optionalMetaType`), Mockingbird.resolve(`optionalAnyType`), Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: MockingbirdTestsHost.StructType, classType: MockingbirdTestsHost.ClassType, enumType: MockingbirdTestsHost.EnumType, stringType: String, boolType: Bool, metaType: ClassType.Type, anyType: Any, anyObjectType: AnyObject) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`structType`), Mockingbird.ArgumentMatcher(`classType`), Mockingbird.ArgumentMatcher(`enumType`), Mockingbird.ArgumentMatcher(`stringType`), Mockingbird.ArgumentMatcher(`boolType`), Mockingbird.ArgumentMatcher(`metaType`), Mockingbird.ArgumentMatcher(`anyType`), Mockingbird.ArgumentMatcher(`anyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool {
      return concreteImplementation(`structType`, `classType`, `enumType`, `stringType`, `boolType`, `metaType`, `anyType`, `anyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: @escaping @autoclosure () -> MockingbirdTestsHost.StructType, classType: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType, enumType: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType, stringType: @escaping @autoclosure () -> String, boolType: @escaping @autoclosure () -> Bool, metaType: @escaping @autoclosure () -> ClassType.Type, anyType: @escaping @autoclosure () -> Any, anyObjectType: @escaping @autoclosure () -> AnyObject) -> Mockingbird.Stubbable<(MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`structType`), Mockingbird.resolve(`classType`), Mockingbird.resolve(`enumType`), Mockingbird.resolve(`stringType`), Mockingbird.resolve(`boolType`), Mockingbird.resolve(`metaType`), Mockingbird.resolve(`anyType`), Mockingbird.resolve(`anyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: @escaping @autoclosure () -> MockingbirdTestsHost.StructType, classType: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType, enumType: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType, stringType: @escaping @autoclosure () -> String, boolType: @escaping @autoclosure () -> Bool, metaType: @escaping @autoclosure () -> ClassType.Type, anyType: @escaping @autoclosure () -> Any, anyObjectType: @escaping @autoclosure () -> AnyObject) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`structType`), Mockingbird.resolve(`classType`), Mockingbird.resolve(`enumType`), Mockingbird.resolve(`stringType`), Mockingbird.resolve(`boolType`), Mockingbird.resolve(`metaType`), Mockingbird.resolve(`anyType`), Mockingbird.resolve(`anyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ArgumentMatchingProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol) -> ArgumentMatchingProtocolMock {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ArrayCollection

public final class ArrayCollectionMock: MockingbirdTestsHost.ArrayCollection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ArrayCollectionMock, rhs: ArrayCollectionMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(objects:)`

  public func method(objects: [String]) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([String]) -> Bool {
      return concreteImplementation(`objects`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(objects:)`

  public func method(objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Stubbable<([String]) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<([String]) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(objects:)`

  public func method(objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ArrayCollection` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ArrayCollection.Protocol) -> ArrayCollectionMock {
  return ArrayCollectionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ArrayTypes

public final class ArrayTypesMock: MockingbirdTestsHost.ArrayTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `anotherVariable`

  public var anotherVariable: [Foundation.NSObject] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.NSObject])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Foundation.NSObject]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `anotherVariable`

  public func getAnotherVariable() -> Mockingbird.Stubbable<() -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [Foundation.NSObject], [Foundation.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Stubbable<([Foundation.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<([Foundation.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `anotherVariable`

  public func getAnotherVariable() -> Mockingbird.Mockable<[Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<[Foundation.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitAnotherVariable`

  public var explicitAnotherVariable: Array<Foundation.NSObject> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<Foundation.NSObject>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Array<Foundation.NSObject>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `explicitAnotherVariable`

  public func getExplicitAnotherVariable() -> Mockingbird.Stubbable<() -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Stubbable<(Array<Foundation.NSObject>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Array<Foundation.NSObject>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitAnotherVariable`

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Array<Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Array<Foundation.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitVariable`

  public var explicitVariable: Array<MockingbirdTestsHost.NSObject> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<MockingbirdTestsHost.NSObject>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Array<MockingbirdTestsHost.NSObject>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `explicitVariable`

  public func getExplicitVariable() -> Mockingbird.Stubbable<() -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setExplicitVariable(_ newValue: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>) -> Mockingbird.Stubbable<(Array<MockingbirdTestsHost.NSObject>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Array<MockingbirdTestsHost.NSObject>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitVariable`

  public func getExplicitVariable() -> Mockingbird.Mockable<Array<MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Array<MockingbirdTestsHost.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setExplicitVariable(_ newValue: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalAnotherVariable`

  public var optionalAnotherVariable: [Foundation.NSObject?] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.NSObject?])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Foundation.NSObject?]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalAnotherVariable`

  public func getOptionalAnotherVariable() -> Mockingbird.Stubbable<() -> [Foundation.NSObject?], [Foundation.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [Foundation.NSObject?], [Foundation.NSObject?]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.NSObject?]) -> Mockingbird.Stubbable<([Foundation.NSObject?]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<([Foundation.NSObject?]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalAnotherVariable`

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<[Foundation.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<[Foundation.NSObject?]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.NSObject?]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalExplicitAnotherVariable`

  public var optionalExplicitAnotherVariable: Array<Foundation.NSObject?> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<Foundation.NSObject?>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Array<Foundation.NSObject?>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalExplicitAnotherVariable`

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Stubbable<() -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Array<Foundation.NSObject?>) -> Mockingbird.Stubbable<(Array<Foundation.NSObject?>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Array<Foundation.NSObject?>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalExplicitAnotherVariable`

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Array<Foundation.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Array<Foundation.NSObject?>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Array<Foundation.NSObject?>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalExplicitVariable`

  public var optionalExplicitVariable: Array<MockingbirdTestsHost.NSObject?> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<MockingbirdTestsHost.NSObject?>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Array<MockingbirdTestsHost.NSObject?>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalExplicitVariable`

  public func getOptionalExplicitVariable() -> Mockingbird.Stubbable<() -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalExplicitVariable(_ newValue: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject?>) -> Mockingbird.Stubbable<(Array<MockingbirdTestsHost.NSObject?>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Array<MockingbirdTestsHost.NSObject?>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalExplicitVariable`

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Array<MockingbirdTestsHost.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Array<MockingbirdTestsHost.NSObject?>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalExplicitVariable(_ newValue: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject?>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalVariable`

  public var optionalVariable: [MockingbirdTestsHost.NSObject?] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.NSObject?])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([MockingbirdTestsHost.NSObject?]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalVariable`

  public func getOptionalVariable() -> Mockingbird.Stubbable<() -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject?]) -> Mockingbird.Stubbable<([MockingbirdTestsHost.NSObject?]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<([MockingbirdTestsHost.NSObject?]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalVariable`

  public func getOptionalVariable() -> Mockingbird.Mockable<[MockingbirdTestsHost.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<[MockingbirdTestsHost.NSObject?]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject?]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variable`

  public var variable: [MockingbirdTestsHost.NSObject] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.NSObject])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([MockingbirdTestsHost.NSObject]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `variable`

  public func getVariable() -> Mockingbird.Stubbable<() -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Stubbable<([MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Stubbable<([MockingbirdTestsHost.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variable`

  public func getVariable() -> Mockingbird.Mockable<[MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<[MockingbirdTestsHost.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ArrayTypesMock, rhs: ArrayTypesMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Stubbable<() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Stubbable<() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> Array<Foundation.NSObject> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<Foundation.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Array<Foundation.NSObject>)()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<Foundation.NSObject>", arguments: [])
    return Mockingbird.Stubbable<() -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<Array<Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Array<Foundation.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> Array<MockingbirdTestsHost.NSObject> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Array<MockingbirdTestsHost.NSObject>)()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Stubbable<() -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<Array<MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Array<MockingbirdTestsHost.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: Array<MockingbirdTestsHost.NSObject>, param2: Array<Foundation.NSObject>) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>, param2: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Stubbable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>, param2: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  // MARK: Stubbable `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> Mockingbird.Stubbable<() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Stubbable<() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> Mockingbird.Mockable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<(Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> [Foundation.NSObject] {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [Foundation.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [Foundation.NSObject])()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.NSObject]", arguments: [])
    return Mockingbird.Stubbable<() -> [Foundation.NSObject], [Foundation.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<[Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<[Foundation.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> [MockingbirdTestsHost.NSObject] {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [MockingbirdTestsHost.NSObject])()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Stubbable<() -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<[MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<[MockingbirdTestsHost.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method(param1:param2:)`

  public func method(param1: [MockingbirdTestsHost.NSObject], param2: [Foundation.NSObject]) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject], param2: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Stubbable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject], param2: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  // MARK: Stubbable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> Mockingbird.Mockable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ArrayTypes` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ArrayTypes.Protocol) -> ArrayTypesMock {
  return ArrayTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericConstraintsProtocol

public final class AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>: MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol, Mockingbird.Mock where ConstrainedType.EquatableType == Int, ConstrainedType.HashableType == String {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ConstrainedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericConstraintsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeGenericConstraintsProtocolMock, rhs: AssociatedTypeGenericConstraintsProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(object:)`

  public func request(object: ConstrainedType) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ConstrainedType) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request(object: @escaping @autoclosure () -> ConstrainedType) -> Mockingbird.Stubbable<(ConstrainedType) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(ConstrainedType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request(object: @escaping @autoclosure () -> ConstrainedType) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `AssociatedTypeGenericConstraintsProtocol<ConstrainedType>` concrete mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol, ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType> {
  return AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericImplementer

public final class AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, Mockingbird.Mock where S.Element == EquatableType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(S.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `equatableTypeVariable`

  override public var equatableTypeVariable: EquatableType {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (EquatableType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `equatableTypeVariable`

  public func getEquatableTypeVariable() -> Mockingbird.Stubbable<() -> EquatableType, EquatableType> {
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> EquatableType, EquatableType>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setEquatableTypeVariable(_ newValue: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `equatableTypeVariable`

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<EquatableType> {
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<EquatableType>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setEquatableTypeVariable(_ newValue: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: AssociatedTypeGenericImplementerMock, rhs: AssociatedTypeGenericImplementerMock) -> Bool {
    return true
  }

  // MARK: Mockable `methodUsingEquatableType(equatable:)`

  public override func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public override func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<EquatableType>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodUsingHashableType(hashable:)`

  public override func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Stubbable<(HashableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(HashableType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `AssociatedTypeGenericImplementer<EquatableType, S>` mock metatype.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, EquatableType: Equatable, S: Sequence>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeGenericImplementerMock<EquatableType, S>.Type {
  return AssociatedTypeGenericImplementerMock.self
}

// MARK: - Mocked AssociatedTypeImplementerProtocol

public final class AssociatedTypeImplementerProtocolMock: MockingbirdTestsHost.AssociatedTypeImplementerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerProtocolMock, rhs: AssociatedTypeImplementerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    return Mockingbird.Mockable<T.HashableType>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    return Mockingbird.Mockable<T.HashableType>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `AssociatedTypeImplementerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol) -> AssociatedTypeImplementerProtocolMock {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeImplementer

public final class AssociatedTypeImplementerMock: MockingbirdTestsHost.AssociatedTypeImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerMock, rhs: AssociatedTypeImplementerMock) -> Bool {
    return true
  }

  // MARK: Mockable `request(object:)`

  public override func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `AssociatedTypeImplementer` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type) -> AssociatedTypeImplementerMock.Type {
  return AssociatedTypeImplementerMock.self
}

// MARK: - Mocked AssociatedTypeProtocol

public final class AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>: MockingbirdTestsHost.AssociatedTypeProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(HashableType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `equatableTypeVariable`

  public var equatableTypeVariable: EquatableType {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (EquatableType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `equatableTypeVariable`

  public func getEquatableTypeVariable() -> Mockingbird.Stubbable<() -> EquatableType, EquatableType> {
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> EquatableType, EquatableType>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setEquatableTypeVariable(_ newValue: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `equatableTypeVariable`

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<EquatableType> {
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<EquatableType>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setEquatableTypeVariable(_ newValue: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `equatableTypeVariable`

  public class var equatableTypeVariable: EquatableType {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (EquatableType) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `equatableTypeVariable`

  public class func getEquatableTypeVariable() -> Mockingbird.Stubbable<() -> EquatableType, EquatableType> {
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> EquatableType, EquatableType>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setEquatableTypeVariable(_ newValue: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `equatableTypeVariable`

  public class func getEquatableTypeVariable() -> Mockingbird.Mockable<EquatableType> {
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<EquatableType>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setEquatableTypeVariable(_ newValue: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public static func ==(lhs: AssociatedTypeProtocolMock, rhs: AssociatedTypeProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<EquatableType>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public static func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public static func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public static func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<EquatableType>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Stubbable<(HashableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(HashableType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `AssociatedTypeProtocol<EquatableType, HashableType>` concrete mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeProtocol, EquatableType: Equatable, HashableType: Hashable>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeProtocolMock<EquatableType, HashableType> {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeSelfReferencingProtocol

public final class AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence>: MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, Mockingbird.Mock where SequenceType.Element == AssociatedTypeSelfReferencingProtocolMock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(SequenceType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeSelfReferencingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeSelfReferencingProtocolMock, rhs: AssociatedTypeSelfReferencingProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(array:)`

  public func request<T: Sequence>(array: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(array:)`

  public func request<T: Sequence>(array: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let arguments = [Mockingbird.resolve(`array`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(array:)`

  public func request<T: Sequence>(array: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let arguments = [Mockingbird.resolve(`array`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(array:)`

  public func request(array: SequenceType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SequenceType) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(array:)`

  public func request(array: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Stubbable<(SequenceType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`array`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(SequenceType) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(array:)`

  public func request(array: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`array`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request(object: AssociatedTypeSelfReferencingProtocolMock) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AssociatedTypeSelfReferencingProtocolMock) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request(object: @escaping @autoclosure () -> AssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Stubbable<(AssociatedTypeSelfReferencingProtocolMock) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(AssociatedTypeSelfReferencingProtocolMock) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request(object: @escaping @autoclosure () -> AssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `AssociatedTypeSelfReferencingProtocol<SequenceType>` concrete mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, SequenceType: Sequence>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeSelfReferencingProtocolMock<SequenceType> {
  return AssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Bird

public final class BirdMock: MockingbirdTestsHost.Bird, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BirdMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `canFly`

  public var canFly: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "canFly.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `canFly`

  public func getCanFly() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setCanFly(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "canFly.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `canFly`

  public func getCanFly() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setCanFly(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "canFly.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: BirdMock, rhs: BirdMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `canEat(_:)`

  public func canEat<T>(_ object: T) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "canEat(_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `canEat(_:)`

  public func canEat<T>(_ object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "canEat(_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `canEat(_:)`

  public func canEat<T>(_ object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "canEat(_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `chirp(volume:)`

  public func chirp(volume: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "chirp(volume:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`volume`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`volume`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `chirp(volume:)`

  public func chirp(volume: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`volume`)]
    let invocation = Mockingbird.Invocation(selectorName: "chirp(volume:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `chirp(volume:)`

  public func chirp(volume: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`volume`)]
    let invocation = Mockingbird.Invocation(selectorName: "chirp(volume:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `eat(_:)`

  public func eat<T>(_ object: T) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "eat(_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `eat(_:)`

  public func eat<T>(_ object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "eat(_:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `eat(_:)`

  public func eat<T>(_ object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "eat(_:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `fly()`

  public func fly() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "fly() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `fly()`

  public func fly() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "fly() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `fly()`

  public func fly() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "fly() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `Bird` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Bird.Protocol) -> BirdMock {
  return BirdMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `childInstanceVariable`

  public var childInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childInstanceVariable`

  public func getChildInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childInstanceVariable`

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childPrivateSetterInstanceVariable`

  public var childPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childPrivateSetterStaticVariable`

  public class var childPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childStaticVariable`

  public class var childStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childStaticVariable`

  public class func getChildStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childStaticVariable`

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ChildProtocolMock, rhs: ChildProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ChildProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ChildProtocol.Protocol) -> ChildProtocolMock {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `childClassVariable`

  override public class var childClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childClassVariable`

  public class func getChildClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childClassVariable`

  public class func getChildClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childComputedInstanceVariable`

  override public var childComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ChildMock, rhs: ChildMock) -> Bool {
    return true
  }

  // MARK: Mockable `childParameterizedClassMethod(param1:_:)`

  public override static func childParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public override func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childTrivialClassMethod()`

  public override static func childTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public override func childTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `Child` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Child.Type) -> ChildMock.Type {
  return ChildMock.self
}

// MARK: - Mocked ClassType

public final class ClassTypeMock: MockingbirdTestsHost.ClassType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ClassTypeMock, rhs: ClassTypeMock) -> Bool {
    return true
  }
}

/// Create a source-attributed `ClassType` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ClassType.Type) -> ClassTypeMock.Type {
  return ClassTypeMock.self
}

// MARK: - Mocked ClosureParametersProtocol

public final class ClosureParametersProtocolMock: MockingbirdTestsHost.ClosureParametersProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClosureParametersProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ClosureParametersProtocolMock, rhs: ClosureParametersProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @autoclosure () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(@autoclosure () -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@autoclosure () -> Void) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @autoclosure () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(@autoclosure () -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@autoclosure () -> Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(@escaping @autoclosure () -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping @autoclosure () -> Void) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(@escaping @autoclosure () -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping @autoclosure () -> Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping (Bool) -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Stubbable<(@escaping (Bool) -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping (Bool) -> Void) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping (Bool) -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Stubbable<(@escaping (Bool) -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping (Bool) -> Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(@escaping () -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping () -> Void) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(@escaping () -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping () -> Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parameterizedClosure(block:)`

  public func parameterizedClosure(block: (Bool) -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedClosure(block:)`

  public func parameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Stubbable<((Bool) -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<((Bool) -> Void) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parameterizedClosure(block:)`

  public func parameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: (Bool) -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Stubbable<((Bool) -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<((Bool) -> Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `trivialClosure(block:)`

  public func trivialClosure(block: () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `trivialClosure(block:)`

  public func trivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(() -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(() -> Void) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `trivialClosure(block:)`

  public func trivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(() -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(() -> Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ClosureParametersProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol) -> ClosureParametersProtocolMock {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ConvenienceInitializerClass

public final class ConvenienceInitializerClassMock: MockingbirdTestsHost.ConvenienceInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConvenienceInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ConvenienceInitializerClassMock, rhs: ConvenienceInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public required override init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `ConvenienceInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type) -> ConvenienceInitializerClassMock.Type {
  return ConvenienceInitializerClassMock.self
}

// MARK: - Mocked DefaultArgumentValuesClass

public final class DefaultArgumentValuesClassMock: MockingbirdTestsHost.DefaultArgumentValuesClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: DefaultArgumentValuesClassMock, rhs: DefaultArgumentValuesClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `method(param1:param2:)`

  public override func method(param1: String, param2: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> String, param2: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Stubbable<(String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> String, param2: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `DefaultArgumentValuesClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type) -> DefaultArgumentValuesClassMock.Type {
  return DefaultArgumentValuesClassMock.self
}

// MARK: - Mocked DefaultArgumentValuesProtocol

public final class DefaultArgumentValuesProtocolMock: MockingbirdTestsHost.DefaultArgumentValuesProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: DefaultArgumentValuesProtocolMock, rhs: DefaultArgumentValuesProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(param1:param2:)`

  public func method(param1: String, param2: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> String, param2: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Stubbable<(String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> String, param2: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `DefaultArgumentValuesProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol) -> DefaultArgumentValuesProtocolMock {
  return DefaultArgumentValuesProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DictionaryCollection

public final class DictionaryCollectionMock: MockingbirdTestsHost.DictionaryCollection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: DictionaryCollectionMock, rhs: DictionaryCollectionMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(objects:)`

  public func method(objects: [String: String]) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([String: String]) -> Bool {
      return concreteImplementation(`objects`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(objects:)`

  public func method(objects: @escaping @autoclosure () -> [String: String]) -> Mockingbird.Stubbable<([String: String]) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<([String: String]) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(objects:)`

  public func method(objects: @escaping @autoclosure () -> [String: String]) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `DictionaryCollection` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DictionaryCollection.Protocol) -> DictionaryCollectionMock {
  return DictionaryCollectionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DictionaryTypes

public final class DictionaryTypesMock: MockingbirdTestsHost.DictionaryTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `anotherVariable`

  public var anotherVariable: [Foundation.URL: Foundation.NSObject] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.URL: Foundation.NSObject])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Foundation.URL: Foundation.NSObject]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `anotherVariable`

  public func getAnotherVariable() -> Mockingbird.Stubbable<() -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Stubbable<([Foundation.URL: Foundation.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<([Foundation.URL: Foundation.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `anotherVariable`

  public func getAnotherVariable() -> Mockingbird.Mockable<[Foundation.URL: Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<[Foundation.URL: Foundation.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitAnotherVariable`

  public var explicitAnotherVariable: Dictionary<Foundation.URL, Foundation.NSObject> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<Foundation.URL, Foundation.NSObject>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `explicitAnotherVariable`

  public func getExplicitAnotherVariable() -> Mockingbird.Stubbable<() -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Stubbable<(Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitAnotherVariable`

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Dictionary<Foundation.URL, Foundation.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitVariable`

  public var explicitVariable: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `explicitVariable`

  public func getExplicitVariable() -> Mockingbird.Stubbable<() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setExplicitVariable(_ newValue: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>) -> Mockingbird.Stubbable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitVariable`

  public func getExplicitVariable() -> Mockingbird.Mockable<Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setExplicitVariable(_ newValue: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalAnotherVariable`

  public var optionalAnotherVariable: [Foundation.URL: Foundation.NSObject?] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.URL: Foundation.NSObject?])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([Foundation.URL: Foundation.NSObject?]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalAnotherVariable`

  public func getOptionalAnotherVariable() -> Mockingbird.Stubbable<() -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject?]) -> Mockingbird.Stubbable<([Foundation.URL: Foundation.NSObject?]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<([Foundation.URL: Foundation.NSObject?]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalAnotherVariable`

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<[Foundation.URL: Foundation.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<[Foundation.URL: Foundation.NSObject?]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalAnotherVariable(_ newValue: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject?]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalExplicitAnotherVariable`

  public var optionalExplicitAnotherVariable: Dictionary<Foundation.URL, Foundation.NSObject?> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<Foundation.URL, Foundation.NSObject?>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Dictionary<Foundation.URL, Foundation.NSObject?>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalExplicitAnotherVariable`

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Stubbable<() -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject?>) -> Mockingbird.Stubbable<(Dictionary<Foundation.URL, Foundation.NSObject?>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Dictionary<Foundation.URL, Foundation.NSObject?>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalExplicitAnotherVariable`

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Dictionary<Foundation.URL, Foundation.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Dictionary<Foundation.URL, Foundation.NSObject?>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalExplicitAnotherVariable(_ newValue: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject?>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalExplicitVariable`

  public var optionalExplicitVariable: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?> {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalExplicitVariable`

  public func getOptionalExplicitVariable() -> Mockingbird.Stubbable<() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalExplicitVariable(_ newValue: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>) -> Mockingbird.Stubbable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalExplicitVariable`

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalExplicitVariable(_ newValue: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalVariable`

  public var optionalVariable: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalVariable`

  public func getOptionalVariable() -> Mockingbird.Stubbable<() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]) -> Mockingbird.Stubbable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalVariable`

  public func getOptionalVariable() -> Mockingbird.Mockable<[MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<[MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variable`

  public var variable: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject])()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `variable`

  public func getVariable() -> Mockingbird.Stubbable<() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Stubbable<() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]) -> Mockingbird.Stubbable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Stubbable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variable`

  public func getVariable() -> Mockingbird.Mockable<[MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<[MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: DictionaryTypesMock, rhs: DictionaryTypesMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Stubbable<() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Stubbable<() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Dictionary<Foundation.URL, Foundation.NSObject>)()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    return Mockingbird.Stubbable<() -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Dictionary<Foundation.URL, Foundation.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod()`

  public func explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>)()
    }
  }

  // MARK: Stubbable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Stubbable<() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Stubbable<() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod()`

  public func explicitMethod() -> Mockingbird.Mockable<Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, param2: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, param2: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Stubbable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, param2: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  // MARK: Stubbable `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> Mockingbird.Stubbable<() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Stubbable<() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> Mockingbird.Mockable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<(Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> [Foundation.URL: Foundation.NSObject] {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [Foundation.URL: Foundation.NSObject])()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    return Mockingbird.Stubbable<() -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<[Foundation.URL: Foundation.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<[Foundation.URL: Foundation.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject])()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Stubbable<() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<[MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<[MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method(param1:param2:)`

  public func method(param1: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], param2: [Foundation.URL: Foundation.NSObject]) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], param2: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Stubbable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], param2: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  // MARK: Stubbable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Stubbable<() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> Mockingbird.Mockable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `DictionaryTypes` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DictionaryTypes.Protocol) -> DictionaryTypesMock {
  return DictionaryTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyInitializerClass

public final class EmptyInitializerClassMock: MockingbirdTestsHost.EmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: EmptyInitializerClassMock, rhs: EmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `EmptyInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.EmptyInitializerClass.Type) -> EmptyInitializerClassMock.Type {
  return EmptyInitializerClassMock.self
}

// MARK: - Mocked EmptyInitializerProtocol

public final class EmptyInitializerProtocolMock: MockingbirdTestsHost.EmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: EmptyInitializerProtocolMock, rhs: EmptyInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `EmptyInitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol) -> EmptyInitializerProtocolMock {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ExtendableProtocol

public final class ExtendableProtocolMock: MockingbirdTestsHost.ExtendableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `anotherExtendedVariable`

  public var anotherExtendedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `anotherExtendedVariable`

  public func getAnotherExtendedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setAnotherExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `anotherExtendedVariable`

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setAnotherExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `baseVariable`

  public var baseVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `extendedVariable`

  public var extendedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `extendedVariable`

  public func getExtendedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `extendedVariable`

  public func getExtendedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ExtendableProtocolMock, rhs: ExtendableProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: Bool) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param1`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param1`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ExtendableProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ExtendableProtocol.Protocol) -> ExtendableProtocolMock {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableEmptyInitializerClass

public final class FailableEmptyInitializerClassMock: MockingbirdTestsHost.FailableEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableEmptyInitializerClassMock, rhs: FailableEmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public required override init?() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableEmptyInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type) -> FailableEmptyInitializerClassMock.Type {
  return FailableEmptyInitializerClassMock.self
}

// MARK: - Mocked FailableEmptyInitializerProtocol

public final class FailableEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableEmptyInitializerProtocolMock, rhs: FailableEmptyInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public required init?() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableEmptyInitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol) -> FailableEmptyInitializerProtocolMock {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableParameterizedInitializerClass

public final class FailableParameterizedInitializerClassMock: MockingbirdTestsHost.FailableParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableParameterizedInitializerClassMock, rhs: FailableParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public required override init?(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableParameterizedInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type) -> FailableParameterizedInitializerClassMock.Type {
  return FailableParameterizedInitializerClassMock.self
}

// MARK: - Mocked FailableParameterizedInitializerProtocol

public final class FailableParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableParameterizedInitializerProtocolMock, rhs: FailableParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init(param1:param2:)`

  public required init?(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableParameterizedInitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol) -> FailableParameterizedInitializerProtocolMock {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerClass

public final class FailableUnwrappedEmptyInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedEmptyInitializerClassMock, rhs: FailableUnwrappedEmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public required override init!() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableUnwrappedEmptyInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type) -> FailableUnwrappedEmptyInitializerClassMock.Type {
  return FailableUnwrappedEmptyInitializerClassMock.self
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerProtocol

public final class FailableUnwrappedEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedEmptyInitializerProtocolMock, rhs: FailableUnwrappedEmptyInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public required init!() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableUnwrappedEmptyInitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol) -> FailableUnwrappedEmptyInitializerProtocolMock {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerClass

public final class FailableUnwrappedParameterizedInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedParameterizedInitializerClassMock, rhs: FailableUnwrappedParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public required override init!(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableUnwrappedParameterizedInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type) -> FailableUnwrappedParameterizedInitializerClassMock.Type {
  return FailableUnwrappedParameterizedInitializerClassMock.self
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerProtocol

public final class FailableUnwrappedParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedParameterizedInitializerProtocolMock, rhs: FailableUnwrappedParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init(param1:param2:)`

  public required init!(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `FailableUnwrappedParameterizedInitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol) -> FailableUnwrappedParameterizedInitializerProtocolMock {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public static func ==(lhs: GrandparentProtocolMock, rhs: GrandparentProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `GrandparentProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.GrandparentProtocol.Protocol) -> GrandparentProtocolMock {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: GrandparentMock, rhs: GrandparentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `Grandparent` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Grandparent.Type) -> GrandparentMock.Type {
  return GrandparentMock.self
}

// MARK: - Mocked InheritedTypeQualificationProtocolGenericImplementer

public final class InheritedTypeQualificationProtocolGenericImplementerMock<T>: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolGenericImplementerMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InheritedTypeQualificationProtocolGenericImplementerMock, rhs: InheritedTypeQualificationProtocolGenericImplementerMock) -> Bool {
    return true
  }

  // MARK: Mockable `lessQualifiedImplementation(param:)`

  public override func lessQualifiedImplementation(param: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  // MARK: Stubbable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Stubbable<(MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<MockingbirdTestsHost.UnscopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<MockingbirdTestsHost.UnscopedType?>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `moreQualifiedImplementation(param:)`

  public override func moreQualifiedImplementation(param: ScopedType) -> ScopedType? {
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  // MARK: Stubbable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Stubbable<(ScopedType) -> ScopedType?, ScopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Stubbable<(ScopedType) -> ScopedType?, ScopedType?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<ScopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<ScopedType?>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `InheritedTypeQualificationProtocolGenericImplementer<T>` mock metatype.
public func mock<MockType: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>, T>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> InheritedTypeQualificationProtocolGenericImplementerMock<T>.Type {
  return InheritedTypeQualificationProtocolGenericImplementerMock.self
}

// MARK: - Mocked InheritedTypeQualificationProtocolImplementer

public final class InheritedTypeQualificationProtocolImplementerMock: MockingbirdTestsHost.InheritedTypeQualificationProtocolImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InheritedTypeQualificationProtocolImplementerMock, rhs: InheritedTypeQualificationProtocolImplementerMock) -> Bool {
    return true
  }

  // MARK: Mockable `lessQualifiedImplementation(param:)`

  public override func lessQualifiedImplementation(param: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  // MARK: Stubbable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Stubbable<(MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<MockingbirdTestsHost.UnscopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<MockingbirdTestsHost.UnscopedType?>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `moreQualifiedImplementation(param:)`

  public override func moreQualifiedImplementation(param: ScopedType) -> ScopedType? {
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  // MARK: Stubbable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Stubbable<(ScopedType) -> ScopedType?, ScopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Stubbable<(ScopedType) -> ScopedType?, ScopedType?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<ScopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<ScopedType?>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `InheritedTypeQualificationProtocolImplementer` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InheritedTypeQualificationProtocolImplementer.Type) -> InheritedTypeQualificationProtocolImplementerMock.Type {
  return InheritedTypeQualificationProtocolImplementerMock.self
}

// MARK: - Mocked InheritedTypeQualificationProtocol

public final class InheritedTypeQualificationProtocolMock<ScopedType>: MockingbirdTestsHost.InheritedTypeQualificationProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ScopedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolMock<ScopedType>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InheritedTypeQualificationProtocolMock, rhs: InheritedTypeQualificationProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  // MARK: Stubbable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Stubbable<(MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<MockingbirdTestsHost.UnscopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<MockingbirdTestsHost.UnscopedType?>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: ScopedType) -> ScopedType? {
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  // MARK: Stubbable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Stubbable<(ScopedType) -> ScopedType?, ScopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Stubbable<(ScopedType) -> ScopedType?, ScopedType?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<ScopedType?> {
    let arguments = [Mockingbird.resolve(`param`)]
    let invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<ScopedType?>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `InheritedTypeQualificationProtocol<ScopedType>` concrete mock instance.
public func mock<MockType: MockingbirdTestsHost.InheritedTypeQualificationProtocol, ScopedType>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> InheritedTypeQualificationProtocolMock<ScopedType> {
  return InheritedTypeQualificationProtocolMock<ScopedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InitializerClass

public final class InitializerClassMock: MockingbirdTestsHost.InitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InitializerClassMock, rhs: InitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param1:_:)`

  public required override init(param1: Bool, _ param2: Int) {
    super.init(param1: `param1`, `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required override init?(param: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required override init!(param: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required init(param: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required override init(param: String) throws {
    try super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `InitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InitializerClass.Type) -> InitializerClassMock.Type {
  return InitializerClassMock.self
}

// MARK: - Mocked InitializerProtocol

public final class InitializerProtocolMock: MockingbirdTestsHost.InitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InitializerProtocolMock, rhs: InitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param1:_:)`

  public required init(param1: Bool, _ param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required init?(param: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required init!(param: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `init(param:)`

  public required init(param: String) throws {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `InitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InitializerProtocol.Protocol) -> InitializerProtocolMock {
  return InitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InoutClass

public final class InoutClassMock: MockingbirdTestsHost.InoutClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutClassMock, rhs: InoutClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `parameterizedMethod(object:)`

  public override func parameterizedMethod(object: inout String) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(inout String) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(inout String) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `InoutClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InoutClass.Type) -> InoutClassMock.Type {
  return InoutClassMock.self
}

// MARK: - Mocked InoutProtocol

public final class InoutProtocolMock: MockingbirdTestsHost.InoutProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutProtocolMock, rhs: InoutProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: inout String) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(inout String) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(inout String) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `InoutProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InoutProtocol.Protocol) -> InoutProtocolMock {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ModuleScopedAssociatedTypeProtocol

public final class ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: ModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, Mockingbird.Mock where Data.Element == MockingbirdTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(Element.self)", "\(Subelement.self)", "\(Data.self)"].joined(separator: ",")
    let staticMockIdentifier = "ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: ModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ModuleScopedAssociatedTypeProtocolMock, rhs: ModuleScopedAssociatedTypeProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `ModuleScopedAssociatedTypeProtocol<Element, Subelement, Data>` concrete mock instance.
public func mock<MockType: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, Element, Subelement, Data: ModuleScopedAssociatedTypeProtocol>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ModuleScopedTypealiasedProtocol

public final class ModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ModuleScopedTypealiasedProtocolMock, rhs: ModuleScopedTypealiasedProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T?) -> T? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T?)()
    }
  }

  // MARK: Stubbable `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: @escaping @autoclosure () -> T?) -> Mockingbird.Stubbable<(T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T?", arguments: arguments)
    return Mockingbird.Stubbable<(T?) -> T?, T?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T?", arguments: arguments)
    return Mockingbird.Mockable<T?>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  // MARK: Stubbable `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T", arguments: arguments)
    return Mockingbird.Stubbable<(T) -> T, T>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T", arguments: arguments)
    return Mockingbird.Mockable<T>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request(object: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject?)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request(object: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Stubbable<(Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Stubbable<(Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request(object: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Foundation.NSObject?> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Foundation.NSObject?>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request(object: Foundation.NSObject) -> Foundation.NSObject {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request(object: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Stubbable<(Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Stubbable<(Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request(object: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Foundation.NSObject> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Foundation.NSObject>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request(object: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject?)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request(object: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject?) -> Mockingbird.Stubbable<(MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request(object: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject?) -> Mockingbird.Mockable<MockingbirdTestsHost.NSObject?> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<MockingbirdTestsHost.NSObject?>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(object:)`

  public func request(object: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request(object: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Stubbable<(MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(object:)`

  public func request(object: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<MockingbirdTestsHost.NSObject> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<MockingbirdTestsHost.NSObject>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ModuleScopedTypealiasedProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol) -> ModuleScopedTypealiasedProtocolMock {
  return ModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NonExtendableClass

public final class NonExtendableClassMock: MockingbirdTestsHost.NonExtendableClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `baseVariable`

  override public var baseVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: NonExtendableClassMock, rhs: NonExtendableClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `trivialBaseMethod()`

  public override func trivialBaseMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `NonExtendableClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.NonExtendableClass.Type) -> NonExtendableClassMock.Type {
  return NonExtendableClassMock.self
}

// MARK: - Mocked OverloadedMethodsClass

public final class OverloadedMethodsClassMock: MockingbirdTestsHost.OverloadedMethodsClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: OverloadedMethodsClassMock, rhs: OverloadedMethodsClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public override func overloadedParameters(param1: Bool, param2: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public override func overloadedParameters(param1: Int, param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Int, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Int, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `overloadedReturnType()`

  public override func overloadedReturnType() -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `overloadedReturnType()`

  public override func overloadedReturnType() -> Int {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Int, Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    return Mockingbird.Stubbable<() -> Int, Int>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    return Mockingbird.Mockable<Int>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `OverloadedMethodsClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.OverloadedMethodsClass.Type) -> OverloadedMethodsClassMock.Type {
  return OverloadedMethodsClassMock.self
}

// MARK: - Mocked OverloadedMethodsProtocol

public final class OverloadedMethodsProtocolMock: MockingbirdTestsHost.OverloadedMethodsProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: OverloadedMethodsProtocolMock, rhs: OverloadedMethodsProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: Bool, param2: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: Int, param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Int, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Int, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `overloadedReturnType()`

  public func overloadedReturnType() -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `overloadedReturnType()`

  public func overloadedReturnType() -> Int {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Int, Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    return Mockingbird.Stubbable<() -> Int, Int>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    return Mockingbird.Mockable<Int>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `OverloadedMethodsProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol) -> OverloadedMethodsProtocolMock {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParameterizedInitializerClass

public final class ParameterizedInitializerClassMock: MockingbirdTestsHost.ParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ParameterizedInitializerClassMock, rhs: ParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public required override init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `ParameterizedInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type) -> ParameterizedInitializerClassMock.Type {
  return ParameterizedInitializerClassMock.self
}

// MARK: - Mocked ParameterizedInitializerProtocol

public final class ParameterizedInitializerProtocolMock: MockingbirdTestsHost.ParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ParameterizedInitializerProtocolMock, rhs: ParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init(param1:param2:)`

  public required init(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `ParameterizedInitializerProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol) -> ParameterizedInitializerProtocolMock {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ParentProtocolMock, rhs: ParentProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `ParentProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ParentProtocol.Protocol) -> ParentProtocolMock {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ParentMock, rhs: ParentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: staticMock.stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: staticMock.mockingContext, invocation: invocation)
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `Parent` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Parent.Type) -> ParentMock.Type {
  return ParentMock.self
}

// MARK: - Mocked RequiredInitializerClass

public final class RequiredInitializerClassMock: MockingbirdTestsHost.RequiredInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RequiredInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: RequiredInitializerClassMock, rhs: RequiredInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public required init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `RequiredInitializerClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.RequiredInitializerClass.Type) -> RequiredInitializerClassMock.Type {
  return RequiredInitializerClassMock.self
}

// MARK: - Mocked ServiceRepository

public final class ServiceRepositoryMock: MockingbirdTestsHost.ServiceRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ServiceRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `testManager`

  public var testManager: MockingbirdTestsHost.TestManager {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.TestManager)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "testManager.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TestManager) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `testManager`

  public func getTestManager() -> Mockingbird.Stubbable<() -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager> {
    let invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
    return Mockingbird.Stubbable<() -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setTestManager(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.TestManager) -> Mockingbird.Stubbable<(MockingbirdTestsHost.TestManager) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "testManager.set", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.TestManager) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `testManager`

  public func getTestManager() -> Mockingbird.Mockable<MockingbirdTestsHost.TestManager> {
    let invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
    return Mockingbird.Mockable<MockingbirdTestsHost.TestManager>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setTestManager(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.TestManager) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "testManager.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: ServiceRepositoryMock, rhs: ServiceRepositoryMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `ServiceRepository` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ServiceRepository.Protocol) -> ServiceRepositoryMock {
  return ServiceRepositoryMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TestCase

public final class TestCaseMock: MockingbirdTestsHost.TestCase, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestCaseMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TestCaseMock, rhs: TestCaseMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `run(description:)`

  public func run(description: String) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "run(description:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`description`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`description`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `run(description:)`

  public func run(description: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(String) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`description`)]
    let invocation = Mockingbird.Invocation(selectorName: "run(description:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(String) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `run(description:)`

  public func run(description: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`description`)]
    let invocation = Mockingbird.Invocation(selectorName: "run(description:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `TestCase` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TestCase.Protocol) -> TestCaseMock {
  return TestCaseMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TestManager

public final class TestManagerMock: MockingbirdTestsHost.TestManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestManagerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `currentTest`

  public var currentTest: MockingbirdTestsHost.Test {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.Test)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "currentTest.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.Test) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `currentTest`

  public func getCurrentTest() -> Mockingbird.Stubbable<() -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test> {
    let invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
    return Mockingbird.Stubbable<() -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setCurrentTest(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.Test) -> Mockingbird.Stubbable<(MockingbirdTestsHost.Test) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "currentTest.set", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.Test) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `currentTest`

  public func getCurrentTest() -> Mockingbird.Mockable<MockingbirdTestsHost.Test> {
    let invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
    return Mockingbird.Mockable<MockingbirdTestsHost.Test>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setCurrentTest(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.Test) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "currentTest.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: TestManagerMock, rhs: TestManagerMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `stopTests()`

  public func stopTests() -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "stopTests() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `stopTests()`

  public func stopTests() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "stopTests() -> Bool", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `stopTests()`

  public func stopTests() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "stopTests() -> Bool", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `TestManager` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TestManager.Protocol) -> TestManagerMock {
  return TestManagerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Test

public final class TestMock: MockingbirdTestsHost.Test, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `testCase`

  public var testCase: MockingbirdTestsHost.TestCase {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.TestCase)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "testCase.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (MockingbirdTestsHost.TestCase) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `testCase`

  public func getTestCase() -> Mockingbird.Stubbable<() -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase> {
    let invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
    return Mockingbird.Stubbable<() -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setTestCase(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Stubbable<(MockingbirdTestsHost.TestCase) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "testCase.set", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.TestCase) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `testCase`

  public func getTestCase() -> Mockingbird.Mockable<MockingbirdTestsHost.TestCase> {
    let invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
    return Mockingbird.Mockable<MockingbirdTestsHost.TestCase>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setTestCase(_ newValue: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "testCase.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: TestMock, rhs: TestMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `add(testCase:)`

  public func add(testCase: MockingbirdTestsHost.TestCase) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "add(testCase:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`testCase`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TestCase) -> Bool {
      return concreteImplementation(`testCase`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `add(testCase:)`

  public func add(testCase: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Stubbable<(MockingbirdTestsHost.TestCase) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`testCase`)]
    let invocation = Mockingbird.Invocation(selectorName: "add(testCase:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(MockingbirdTestsHost.TestCase) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `add(testCase:)`

  public func add(testCase: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`testCase`)]
    let invocation = Mockingbird.Invocation(selectorName: "add(testCase:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `Test` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Test.Protocol) -> TestMock {
  return TestMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TopLevelType

public final class TopLevelTypeMock: MockingbirdTestsHost.TopLevelType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TopLevelTypeMock, rhs: TopLevelTypeMock) -> Bool {
    return true
  }

  // MARK: Mockable `topLevelMethod(param1:param2:)`

  public override func topLevelMethod(param1: SecondLevelType, param2: SecondLevelType.ThirdLevelType) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `topLevelMethod(param1:param2:)`

  public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `topLevelMethod(param1:param2:)`

  public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: - Mocked SecondLevelType
  
  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }
  
    public static func ==(lhs: SecondLevelTypeMock, rhs: SecondLevelTypeMock) -> Bool {
      return true
    }
  
    // MARK: Mockable `secondLevelMethod(param1:param2:)`
  
    public override func secondLevelMethod(param1: TopLevelType, param2: ThirdLevelType) -> Bool {
      let invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (TopLevelType, ThirdLevelType) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else {
        return (implementation as! () -> Bool)()
      }
    }
  
    // MARK: Stubbable `secondLevelMethod(param1:param2:)`
  
    public func secondLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> ThirdLevelType) -> Mockingbird.Stubbable<(TopLevelType, ThirdLevelType) -> Bool, Bool> {
      let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: arguments)
      return Mockingbird.Stubbable<(TopLevelType, ThirdLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
    }
  
    // MARK: Verifiable `secondLevelMethod(param1:param2:)`
  
    public func secondLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> ThirdLevelType) -> Mockingbird.Mockable<Bool> {
      let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: arguments)
      return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
    }
  
    // MARK: - Mocked ThirdLevelInheritingTopLevelType
    
    public final class ThirdLevelInheritingTopLevelTypeMock: ThirdLevelInheritingTopLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingTopLevelTypeMock, rhs: ThirdLevelInheritingTopLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> TopLevelType {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> TopLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> TopLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> TopLevelType)()
        }
      }
    
      // MARK: Stubbable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Stubbable<() -> TopLevelType, TopLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> TopLevelType", arguments: [])
        return Mockingbird.Stubbable<() -> TopLevelType, TopLevelType>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<TopLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> TopLevelType", arguments: [])
        return Mockingbird.Mockable<TopLevelType>(mockingContext: mockingContext, invocation: invocation)
      }
    
      // MARK: Mockable `topLevelMethod(param1:param2:)`
    
      public override func topLevelMethod(param1: SecondLevelType, param2: SecondLevelType.ThirdLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `topLevelMethod(param1:param2:)`
    
      public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `topLevelMethod(param1:param2:)`
    
      public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
      }
    }
    
    /// Create a source-attributed `ThirdLevelInheritingTopLevelType` mock metatype.
    public func mock(file: StaticString = #file, line: UInt = #line, _ type: ThirdLevelInheritingTopLevelType.Type) -> ThirdLevelInheritingTopLevelTypeMock.Type {
      return ThirdLevelInheritingTopLevelTypeMock.self
    }
  
    // MARK: - Mocked ThirdLevelInheritingThirdLevelType
    
    public final class ThirdLevelInheritingThirdLevelTypeMock: ThirdLevelInheritingThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingThirdLevelTypeMock, rhs: ThirdLevelInheritingThirdLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> ThirdLevelType {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> ThirdLevelType)()
        }
      }
    
      // MARK: Stubbable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Stubbable<() -> ThirdLevelType, ThirdLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Stubbable<() -> ThirdLevelType, ThirdLevelType>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<ThirdLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<ThirdLevelType>(mockingContext: mockingContext, invocation: invocation)
      }
    
      // MARK: Mockable `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
      }
    }
    
    /// Create a source-attributed `ThirdLevelInheritingThirdLevelType` mock metatype.
    public func mock(file: StaticString = #file, line: UInt = #line, _ type: ThirdLevelInheritingThirdLevelType.Type) -> ThirdLevelInheritingThirdLevelTypeMock.Type {
      return ThirdLevelInheritingThirdLevelTypeMock.self
    }
  
    // MARK: - Mocked ThirdLevelInheritingPartiallyQualifiedThirdLevelType
    
    public final class ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock: ThirdLevelInheritingPartiallyQualifiedThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock, rhs: ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> ThirdLevelType {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> ThirdLevelType)()
        }
      }
    
      // MARK: Stubbable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Stubbable<() -> ThirdLevelType, ThirdLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Stubbable<() -> ThirdLevelType, ThirdLevelType>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<ThirdLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<ThirdLevelType>(mockingContext: mockingContext, invocation: invocation)
      }
    
      // MARK: Mockable `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
      }
    }
    
    /// Create a source-attributed `ThirdLevelInheritingPartiallyQualifiedThirdLevelType` mock metatype.
    public func mock(file: StaticString = #file, line: UInt = #line, _ type: ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type) -> ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock.Type {
      return ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock.self
    }
  
    // MARK: - Mocked ThirdLevelInheritingFullyQualifiedThirdLevelType
    
    public final class ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock: ThirdLevelInheritingFullyQualifiedThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock, rhs: ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> ThirdLevelType {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> ThirdLevelType)()
        }
      }
    
      // MARK: Stubbable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Stubbable<() -> ThirdLevelType, ThirdLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Stubbable<() -> ThirdLevelType, ThirdLevelType>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<ThirdLevelType> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<ThirdLevelType>(mockingContext: mockingContext, invocation: invocation)
      }
    
      // MARK: Mockable `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
      }
    }
    
    /// Create a source-attributed `ThirdLevelInheritingFullyQualifiedThirdLevelType` mock metatype.
    public func mock(file: StaticString = #file, line: UInt = #line, _ type: ThirdLevelInheritingFullyQualifiedThirdLevelType.Type) -> ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock.Type {
      return ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock.self
    }
  
    // MARK: - Mocked ThirdLevelType
    
    public final class ThirdLevelTypeMock: ThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelTypeMock, rhs: ThirdLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
      }
    
      // MARK: Verifiable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
      }
    }
    
    /// Create a source-attributed `ThirdLevelType` mock metatype.
    public func mock(file: StaticString = #file, line: UInt = #line, _ type: ThirdLevelType.Type) -> ThirdLevelTypeMock.Type {
      return ThirdLevelTypeMock.self
    }
  }
  
  /// Create a source-attributed `SecondLevelType` mock metatype.
  public func mock(file: StaticString = #file, line: UInt = #line, _ type: SecondLevelType.Type) -> SecondLevelTypeMock.Type {
    return SecondLevelTypeMock.self
  }
}

/// Create a source-attributed `TopLevelType` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.Type) -> TopLevelTypeMock.Type {
  return TopLevelTypeMock.self
}

// MARK: - Mocked Tree

public final class TreeMock: MockingbirdTestsHost.Tree, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TreeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TreeMock, rhs: TreeMock) -> Bool {
    return true
  }

  // MARK: Mockable `drop(_:)`

  public override func drop(_ fruit: Fruit) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "drop(_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`fruit`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Fruit) -> Void {
      concreteImplementation(`fruit`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `drop(_:)`

  public func drop(_ fruit: @escaping @autoclosure () -> Fruit) -> Mockingbird.Stubbable<(Fruit) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`fruit`)]
    let invocation = Mockingbird.Invocation(selectorName: "drop(_:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Fruit) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `drop(_:)`

  public func drop(_ fruit: @escaping @autoclosure () -> Fruit) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`fruit`)]
    let invocation = Mockingbird.Invocation(selectorName: "drop(_:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `init(with:)`

  public required override init(with bird: MockingbirdTestsHost.Bird) {
    super.init(with: `bird`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(with:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`bird`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mockable `shake()`

  public override func shake() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "shake() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `shake()`

  public func shake() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "shake() -> Void", arguments: [])
    return Mockingbird.Stubbable<() -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `shake()`

  public func shake() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "shake() -> Void", arguments: [])
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: - Mocked Fruit
  
  public final class FruitMock: Fruit, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        FruitMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }
  
    public static func ==(lhs: FruitMock, rhs: FruitMock) -> Bool {
      return true
    }
  
    // MARK: Mockable `init(size:)`
  
    public required override init(size: Int) {
      super.init(size: `size`)
      Mockingbird.checkVersion(for: self)
      let invocation = Mockingbird.Invocation(selectorName: "init(size:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`size`)])
      mockingContext.didInvoke(invocation)
    }
  }
  
  /// Create a source-attributed `Fruit` mock metatype.
  public func mock(file: StaticString = #file, line: UInt = #line, _ type: Fruit.Type) -> FruitMock.Type {
    return FruitMock.self
  }
}

/// Create a source-attributed `Tree` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Tree.Type) -> TreeMock.Type {
  return TreeMock.self
}

// MARK: - Mocked TupleTypes

public final class TupleTypesMock: MockingbirdTestsHost.TupleTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TupleTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `anotherVariable`

  public var anotherVariable: (Foundation.URL, Foundation.NSObject) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (Foundation.URL, Foundation.NSObject))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((Foundation.URL, Foundation.NSObject)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `anotherVariable`

  public func getAnotherVariable() -> Mockingbird.Stubbable<() -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setAnotherVariable(_ newValue: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Stubbable<((Foundation.URL, Foundation.NSObject)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((Foundation.URL, Foundation.NSObject)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `anotherVariable`

  public func getAnotherVariable() -> Mockingbird.Mockable<(Foundation.URL, Foundation.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<(Foundation.URL, Foundation.NSObject)>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setAnotherVariable(_ newValue: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledAnotherVariable`

  public var labeledAnotherVariable: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `labeledAnotherVariable`

  public func getLabeledAnotherVariable() -> Mockingbird.Stubbable<() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setLabeledAnotherVariable(_ newValue: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Stubbable<((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledAnotherVariable`

  public func getLabeledAnotherVariable() -> Mockingbird.Mockable<(a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<(a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setLabeledAnotherVariable(_ newValue: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledVariable`

  public var labeledVariable: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "labeledVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `labeledVariable`

  public func getLabeledVariable() -> Mockingbird.Stubbable<() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setLabeledVariable(_ newValue: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))) -> Mockingbird.Stubbable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "labeledVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledVariable`

  public func getLabeledVariable() -> Mockingbird.Mockable<(a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
    return Mockingbird.Mockable<(a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setLabeledVariable(_ newValue: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "labeledVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalAnotherVariable`

  public var optionalAnotherVariable: (Foundation.URL?, Foundation.NSObject?) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (Foundation.URL?, Foundation.NSObject?))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((Foundation.URL?, Foundation.NSObject?)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalAnotherVariable`

  public func getOptionalAnotherVariable() -> Mockingbird.Stubbable<() -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalAnotherVariable(_ newValue: @escaping @autoclosure () -> (Foundation.URL?, Foundation.NSObject?)) -> Mockingbird.Stubbable<((Foundation.URL?, Foundation.NSObject?)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((Foundation.URL?, Foundation.NSObject?)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalAnotherVariable`

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<(Foundation.URL?, Foundation.NSObject?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<(Foundation.URL?, Foundation.NSObject?)>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalAnotherVariable(_ newValue: @escaping @autoclosure () -> (Foundation.URL?, Foundation.NSObject?)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalLabeledAnotherVariable`

  public var optionalLabeledAnotherVariable: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalLabeledAnotherVariable`

  public func getOptionalLabeledAnotherVariable() -> Mockingbird.Stubbable<() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalLabeledAnotherVariable(_ newValue: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)) -> Mockingbird.Stubbable<((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalLabeledAnotherVariable`

  public func getOptionalLabeledAnotherVariable() -> Mockingbird.Mockable<(a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<(a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalLabeledAnotherVariable(_ newValue: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalLabeledVariable`

  public var optionalLabeledVariable: (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalLabeledVariable`

  public func getOptionalLabeledVariable() -> Mockingbird.Stubbable<() -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalLabeledVariable(_ newValue: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)) -> Mockingbird.Stubbable<((a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalLabeledVariable`

  public func getOptionalLabeledVariable() -> Mockingbird.Mockable<(a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
    return Mockingbird.Mockable<(a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalLabeledVariable(_ newValue: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `optionalVariable`

  public var optionalVariable: (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `optionalVariable`

  public func getOptionalVariable() -> Mockingbird.Stubbable<() -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setOptionalVariable(_ newValue: @escaping @autoclosure () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)) -> Mockingbird.Stubbable<((MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<((MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `optionalVariable`

  public func getOptionalVariable() -> Mockingbird.Mockable<(MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)> {
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<(MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setOptionalVariable(_ newValue: @escaping @autoclosure () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "optionalVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variable`

  public var variable: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `variable`

  public func getVariable() -> Mockingbird.Stubbable<() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Stubbable<() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) -> Mockingbird.Stubbable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Stubbable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variable`

  public func getVariable() -> Mockingbird.Mockable<(MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<(MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setVariable(_ newValue: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "variable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: TupleTypesMock, rhs: TupleTypesMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `labeledMethod()`

  public func labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  // MARK: Stubbable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Stubbable<() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Stubbable<() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Mockable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledMethod()`

  public func labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  // MARK: Stubbable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Stubbable<() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Stubbable<() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Mockable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledMethod()`

  public func labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))()
    }
  }

  // MARK: Stubbable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Stubbable<() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Stubbable<() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Mockable<(a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<(a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledMethod()`

  public func labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)))()
    }
  }

  // MARK: Stubbable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Stubbable<() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    return Mockingbird.Stubbable<() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledMethod()`

  public func labeledMethod() -> Mockingbird.Mockable<(a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    return Mockingbird.Mockable<(a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledMethod(param1:param2:)`

  public func labeledMethod(param1: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), param2: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `labeledMethod(param1:param2:)`

  public func labeledMethod(param1: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), param2: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Stubbable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledMethod(param1:param2:)`

  public func labeledMethod(param1: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), param2: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `labeledMethodWithParameterLabels()`

  public func labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  // MARK: Stubbable `labeledMethodWithParameterLabels()`

  public func labeledMethodWithParameterLabels() -> Mockingbird.Stubbable<() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Stubbable<() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `labeledMethodWithParameterLabels()`

  public func labeledMethodWithParameterLabels() -> Mockingbird.Mockable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation = Mockingbird.Invocation(selectorName: "labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Stubbable<() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Stubbable<() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> (Foundation.URL, Foundation.NSObject) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Foundation.URL, Foundation.NSObject) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Foundation.URL, Foundation.NSObject))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    return Mockingbird.Stubbable<() -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<(Foundation.URL, Foundation.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    return Mockingbird.Mockable<(Foundation.URL, Foundation.NSObject)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method()`

  public func method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))()
    }
  }

  // MARK: Stubbable `method()`

  public func method() -> Mockingbird.Stubbable<() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    return Mockingbird.Stubbable<() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method()`

  public func method() -> Mockingbird.Mockable<(MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation = Mockingbird.Invocation(selectorName: "method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    return Mockingbird.Mockable<(MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `method(param1:param2:)`

  public func method(param1: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), param2: (Foundation.URL, Foundation.NSObject)) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), param2: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Stubbable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(param1:param2:)`

  public func method(param1: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), param2: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  // MARK: Stubbable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> Mockingbird.Stubbable<() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Stubbable<() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> Mockingbird.Mockable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `TupleTypes` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TupleTypes.Protocol) -> TupleTypesMock {
  return TupleTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TypealiasedClass

public final class TypealiasedClassMock: MockingbirdTestsHost.TypealiasedClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TypealiasedClassMock, rhs: TypealiasedClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `request(callback:)`

  public override func request(callback: IndirectCallback) -> Foundation.NSObject {
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> Foundation.NSObject {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  // MARK: Stubbable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Stubbable<(IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Stubbable<(IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Foundation.NSObject> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Foundation.NSObject>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(callback:)`

  public override func request(callback: IndirectCallback) -> IndirectRequestResult {
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  // MARK: Stubbable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Stubbable<(IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Stubbable<(IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<IndirectRequestResult>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(escapingCallback:)`

  public override func request(escapingCallback: @escaping IndirectCallback) -> IndirectRequestResult {
    let invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`escapingCallback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  // MARK: Stubbable `request(escapingCallback:)`

  public func request(escapingCallback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Stubbable<(@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`escapingCallback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(escapingCallback:)`

  public func request(escapingCallback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`escapingCallback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<IndirectRequestResult>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `TypealiasedClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TypealiasedClass.Type) -> TypealiasedClassMock.Type {
  return TypealiasedClassMock.self
}

// MARK: - Mocked TypealiasedProtocol

public final class TypealiasedProtocolMock: MockingbirdTestsHost.TypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TypealiasedProtocolMock, rhs: TypealiasedProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(callback:)`

  public func request(callback: IndirectCallback) -> Foundation.NSObject {
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> Foundation.NSObject {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  // MARK: Stubbable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Stubbable<(IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Stubbable<(IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Foundation.NSObject> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Foundation.NSObject>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(callback:)`

  public func request(callback: IndirectCallback) -> IndirectRequestResult {
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  // MARK: Stubbable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Stubbable<(IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Stubbable<(IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(callback:)`

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`callback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<IndirectRequestResult>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `request(escapingCallback:)`

  public func request(escapingCallback: @escaping IndirectCallback) -> IndirectRequestResult {
    let invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`escapingCallback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  // MARK: Stubbable `request(escapingCallback:)`

  public func request(escapingCallback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Stubbable<(@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`escapingCallback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Stubbable<(@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `request(escapingCallback:)`

  public func request(escapingCallback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<IndirectRequestResult> {
    let arguments = [Mockingbird.resolve(`escapingCallback`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<IndirectRequestResult>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `TypealiasedProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol) -> TypealiasedProtocolMock {
  return TypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UndefinedArgumentLabels

public final class UndefinedArgumentLabelsMock: MockingbirdTestsHost.UndefinedArgumentLabels, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UndefinedArgumentLabelsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: UndefinedArgumentLabelsMock, rhs: UndefinedArgumentLabelsMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(_:_:_:_:)`

  public func method(_ param1: Bool, _ param2: String, _ someParam: Int, _ param4: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`), Mockingbird.ArgumentMatcher(`someParam`), Mockingbird.ArgumentMatcher(`param4`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, String, Int, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`, `someParam`, `param4`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(_:_:_:_:)`

  public func method(_ param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> String, _ someParam: @escaping @autoclosure () -> Int, _ param4: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool, String, Int, Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<(Bool, String, Int, Bool) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `method(_:_:_:_:)`

  public func method(_ param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> String, _ someParam: @escaping @autoclosure () -> Int, _ param4: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `UndefinedArgumentLabels` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol) -> UndefinedArgumentLabelsMock {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariablesContainer

public final class VariablesContainerMock: MockingbirdTestsHost.VariablesContainer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `computedVariable`

  override public var computedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "computedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `computedVariable`

  public func getComputedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    return Mockingbird.Stubbable<() -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func setComputedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.set", arguments: arguments)
    return Mockingbird.Stubbable<(Bool) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `computedVariable`

  public func getComputedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func setComputedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public static func ==(lhs: VariablesContainerMock, rhs: VariablesContainerMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `VariablesContainer` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariablesContainer.Type) -> VariablesContainerMock.Type {
  return VariablesContainerMock.self
}

// MARK: - Mocked VariadicClass

public final class VariadicClassMock: MockingbirdTestsHost.VariadicClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: VariadicClassMock, rhs: VariadicClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public override func variadicMethod(objects: Bool..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public override func variadicMethod(objects: String..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variadicMethodAsFinalParam(param1:objects:)`

  public override func variadicMethodAsFinalParam(param1: Int, objects: String...) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variadicReturningMethod(objects:param2:)`

  public override func variadicReturningMethod(objects: Bool..., param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `VariadicClass` mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariadicClass.Type) -> VariadicClassMock.Type {
  return VariadicClassMock.self
}

// MARK: - Mocked VariadicProtocol

public final class VariadicProtocolMock: MockingbirdTestsHost.VariadicProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.3.0", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: VariadicProtocolMock, rhs: VariadicProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: Bool..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: String..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: Int, objects: String...) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Void>(mockingContext: mockingContext, invocation: invocation)
  }

  // MARK: Mockable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: Bool..., param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>(stubbingContext: stubbingContext, invocation: invocation)
  }

  // MARK: Verifiable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Bool>(mockingContext: mockingContext, invocation: invocation)
  }
}

/// Create a source-attributed `VariadicProtocol` concrete mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariadicProtocol.Protocol) -> VariadicProtocolMock {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line))
}
