//
//  Mocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird on 8/17/19.
//  DO NOT EDIT
//

@testable import MockingbirdTestsHost
@testable import Mockingbird
import Foundation

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, MockingbirdMock {
  static let staticMock = ChildStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `childClassVariable`

  override public class var childClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childClassVariable`

  public class func getChildClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childClassVariable`

  public class func getChildClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childComputedInstanceVariable`

  override public var childComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: ChildMock, rhs: ChildMock) -> Bool {
    return true
  }

  // MARK: Mockable `childParameterizedClassMethod(param1:_:)`

  public override static func childParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public override func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childTrivialClassMethod()`

  public override static func childTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public override func childTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class ChildStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, MockingbirdMock {
  static let staticMock = ChildProtocolStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `childInstanceVariable`

  public var childInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childInstanceVariable`

  public func getChildInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childInstanceVariable`

  public func getChildInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childPrivateSetterInstanceVariable`

  public var childPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childPrivateSetterStaticVariable`

  public class var childPrivateSetterStaticVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterStaticVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childStaticVariable`

  public class var childStaticVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childStaticVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childStaticVariable`

  public class func getChildStaticVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childStaticVariable`

  public class func getChildStaticVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: ChildProtocolMock, rhs: ChildProtocolMock) -> Bool {
    return true
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialStaticMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialStaticMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialStaticMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class ChildProtocolStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, MockingbirdMock {
  static let staticMock = GrandparentStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: GrandparentMock, rhs: GrandparentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class GrandparentStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, MockingbirdMock {
  static let staticMock = GrandparentProtocolStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterStaticVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentStaticVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: GrandparentProtocolMock, rhs: GrandparentProtocolMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialStaticMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialStaticMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialStaticMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class GrandparentProtocolStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, MockingbirdMock {
  static let staticMock = ParentStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: ParentMock, rhs: ParentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class ParentStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, MockingbirdMock {
  static let staticMock = ParentProtocolStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterStaticVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentStaticVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: ParentProtocolMock, rhs: ParentProtocolMock) -> Bool {
    return true
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialStaticMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialStaticMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialStaticMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class ParentProtocolStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}