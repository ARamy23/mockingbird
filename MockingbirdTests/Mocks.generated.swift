//
//  Mocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird on 8/16/19.
//  DO NOT EDIT
//

@testable import MockingbirdTestsHost
@testable import Mockingbird
import Foundation

// MARK: - Mocked Child

public final class ChildMock: Child, MockingbirdMock {
  static let staticMock = ChildStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `childClassVariable`

  override public class var childClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childClassVariable`

  public class func getChildClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childClassVariable`

  public class func getChildClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childComputedInstanceVariable`

  override public var childComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: ChildMock, rhs: ChildMock) -> Bool {
    return true
  }

  // MARK: Mockable `childParameterizedClassMethod(param1:_:)`

  public override static func childParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public override func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childTrivialClassMethod()`

  public override static func childTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public override func childTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "childTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class ChildStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: Grandparent, MockingbirdMock {
  static let staticMock = GrandparentStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: GrandparentMock, rhs: GrandparentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class GrandparentStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}

// MARK: - Mocked Parent

public final class ParentMock: Parent, MockingbirdMock {
  static let staticMock = ParentStaticMock()
  public let mockingContext = MockingbirdMockingContext()
  public let stubbingContext = MockingbirdStubbingContext()

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      _ = try? (try? staticMock.stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
    }
    set {
      let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set",
                                             arguments: [MockingbirdMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      _ = try? (try? stubbingContext.implementation(for: invocation))?(invocation)
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedStub<Bool> {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedStub<Bool> {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
    expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> MockingbirdScopedMock {
    let matcherNewValue = resolve(newValue)
    let arguments: [MockingbirdMatcher] = [
      (matcherNewValue as? MockingbirdMatcher) ?? MockingbirdMatcher(newValue as AnyObject as? Bool)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  public static func ==(lhs: ParentMock, rhs: ParentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "grandparentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    return (try? (try! staticMock.stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: [MockingbirdMatcher(`param1`), MockingbirdMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    return (try? (try! stubbingContext.implementation(for: invocation))(invocation)) as! Bool
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedStub<Bool> {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> MockingbirdScopedMock {
    let matcherParam1 = resolve(`param1`)
    let matcherParam2 = resolve(`param2`)
    let arguments: [MockingbirdMatcher] = [
      (matcherParam1 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam1 as AnyObject as? Bool),
      (matcherParam2 as? MockingbirdMatcher) ?? MockingbirdMatcher(matcherParam2 as AnyObject as? Int)
    ]
    let invocation = MockingbirdInvocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool",
                                           arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    guard let implementation = try? staticMock.stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      staticMock.stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialClassMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(staticMock.mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    mockingContext.didInvoke(invocation)
    guard let implementation = try? stubbingContext.implementation(for: invocation) else { return }
    (try? implementation(invocation)) as! Void
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedStub<Void> {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let stub = DispatchQueue.currentStub {
      stubbingContext.swizzle(invocation, with: stub.implementation)
    }
    return MockingbirdScopedStub<Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> MockingbirdScopedMock {
    let invocation = MockingbirdInvocation(selectorName: "parentTrivialInstanceMethod() -> Void",
                                           arguments: [])
    if let expectation = DispatchQueue.currentExpectation {
      expect(mockingContext, handled: invocation, using: expectation)
    }
    return MockingbirdScopedMock()
  }

  internal final class ParentStaticMock: MockingbirdMock {
    public let mockingContext = MockingbirdMockingContext()
    public let stubbingContext = MockingbirdStubbingContext()
  }
}