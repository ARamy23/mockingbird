//
//  Mocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird v0.4.2.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import MockingbirdTestsHost
import CoreAudio
import CoreData
import CoreFoundation
import CoreImage
import CoreML
import CoreText
import Foundation
import ObjectiveC
import class CoreFoundation.CFArray
import enum CoreText.CTFontUIFontType

private class Synchronized<T> {
  private var internalValue: T
  fileprivate var value: T {
    get {
      lock.wait()
      defer { lock.signal() }
      return internalValue
    }

    set {
      lock.wait()
      defer { lock.signal() }
      internalValue = newValue
    }
  }
  private let lock = DispatchSemaphore(value: 1)

  fileprivate init(_ value: T) {
    self.internalValue = value
  }

  fileprivate func update(_ block: (inout T) throws -> Void) rethrows {
    lock.wait()
    defer { lock.signal() }
    try block(&internalValue)
  }
}

private var genericTypesStaticMocks = Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked ArgumentMatchingProtocol

public final class ArgumentMatchingProtocolMock: MockingbirdTestsHost.ArgumentMatchingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArgumentMatchingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ArgumentMatchingProtocolMock, rhs: ArgumentMatchingProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: MockingbirdTestsHost.StructType?, optionalClassType: MockingbirdTestsHost.ClassType?, optionalEnumType: MockingbirdTestsHost.EnumType?, optionalStringType: String?, optionalBoolType: Bool?, optionalMetaType: ClassType.Type?, optionalAnyType: Any?, optionalAnyObjectType: AnyObject?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalStructType`), Mockingbird.ArgumentMatcher(`optionalClassType`), Mockingbird.ArgumentMatcher(`optionalEnumType`), Mockingbird.ArgumentMatcher(`optionalStringType`), Mockingbird.ArgumentMatcher(`optionalBoolType`), Mockingbird.ArgumentMatcher(`optionalMetaType`), Mockingbird.ArgumentMatcher(`optionalAnyType`), Mockingbird.ArgumentMatcher(`optionalAnyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool {
      return concreteImplementation(`optionalStructType`, `optionalClassType`, `optionalEnumType`, `optionalStringType`, `optionalBoolType`, `optionalMetaType`, `optionalAnyType`, `optionalAnyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func method(optionalStructType: @escaping @autoclosure () -> MockingbirdTestsHost.StructType?, optionalClassType: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType?, optionalEnumType: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType?, optionalStringType: @escaping @autoclosure () -> String?, optionalBoolType: @escaping @autoclosure () -> Bool?, optionalMetaType: @escaping @autoclosure () -> ClassType.Type?, optionalAnyType: @escaping @autoclosure () -> Any?, optionalAnyObjectType: @escaping @autoclosure () -> AnyObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`optionalStructType`), Mockingbird.resolve(`optionalClassType`), Mockingbird.resolve(`optionalEnumType`), Mockingbird.resolve(`optionalStringType`), Mockingbird.resolve(`optionalBoolType`), Mockingbird.resolve(`optionalMetaType`), Mockingbird.resolve(`optionalAnyType`), Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType?, MockingbirdTestsHost.ClassType?, MockingbirdTestsHost.EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: MockingbirdTestsHost.StructType, classType: MockingbirdTestsHost.ClassType, enumType: MockingbirdTestsHost.EnumType, stringType: String, boolType: Bool, metaType: ClassType.Type, anyType: Any, anyObjectType: AnyObject) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`structType`), Mockingbird.ArgumentMatcher(`classType`), Mockingbird.ArgumentMatcher(`enumType`), Mockingbird.ArgumentMatcher(`stringType`), Mockingbird.ArgumentMatcher(`boolType`), Mockingbird.ArgumentMatcher(`metaType`), Mockingbird.ArgumentMatcher(`anyType`), Mockingbird.ArgumentMatcher(`anyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool {
      return concreteImplementation(`structType`, `classType`, `enumType`, `stringType`, `boolType`, `metaType`, `anyType`, `anyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func method(structType: @escaping @autoclosure () -> MockingbirdTestsHost.StructType, classType: @escaping @autoclosure () -> MockingbirdTestsHost.ClassType, enumType: @escaping @autoclosure () -> MockingbirdTestsHost.EnumType, stringType: @escaping @autoclosure () -> String, boolType: @escaping @autoclosure () -> Bool, metaType: @escaping @autoclosure () -> ClassType.Type, anyType: @escaping @autoclosure () -> Any, anyObjectType: @escaping @autoclosure () -> AnyObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`structType`), Mockingbird.resolve(`classType`), Mockingbird.resolve(`enumType`), Mockingbird.resolve(`stringType`), Mockingbird.resolve(`boolType`), Mockingbird.resolve(`metaType`), Mockingbird.resolve(`anyType`), Mockingbird.resolve(`anyObjectType`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.StructType, MockingbirdTestsHost.ClassType, MockingbirdTestsHost.EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ArgumentMatchingProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol) -> ArgumentMatchingProtocolMock {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ArrayCollection

public final class ArrayCollectionMock: MockingbirdTestsHost.ArrayCollection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ArrayCollectionMock, rhs: ArrayCollectionMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method(objects:)`

  public func method(objects: [String]) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([String]) -> Bool {
      return concreteImplementation(`objects`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func method(objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String]) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String]) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ArrayCollection` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ArrayCollection.Protocol) -> ArrayCollectionMock {
  return ArrayCollectionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ArrayTypes

public final class ArrayTypesMock: MockingbirdTestsHost.ArrayTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArrayTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `anotherVariable`

  public var anotherVariable: [Foundation.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.NSObject])()
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitAnotherVariable`

  public var explicitAnotherVariable: Array<Foundation.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<Foundation.NSObject>)()
    }
  }

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitVariable`

  public var explicitVariable: Array<MockingbirdTestsHost.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<MockingbirdTestsHost.NSObject>)()
    }
  }

  public func getExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalAnotherVariable`

  public var optionalAnotherVariable: [Foundation.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.NSObject?])()
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject?], [Foundation.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.NSObject?], [Foundation.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalExplicitAnotherVariable`

  public var optionalExplicitAnotherVariable: Array<Foundation.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<Foundation.NSObject?>)()
    }
  }

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<Foundation.NSObject?>, Array<Foundation.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalExplicitVariable`

  public var optionalExplicitVariable: Array<MockingbirdTestsHost.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Array<MockingbirdTestsHost.NSObject?>)()
    }
  }

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Array<MockingbirdTestsHost.NSObject?>, Array<MockingbirdTestsHost.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalVariable`

  public var optionalVariable: [MockingbirdTestsHost.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.NSObject?])()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variable`

  public var variable: [MockingbirdTestsHost.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.NSObject])()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: ArrayTypesMock, rhs: ArrayTypesMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> Array<Foundation.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<Foundation.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Array<Foundation.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Array<Foundation.NSObject>)()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<Foundation.NSObject>, Array<Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> Array<MockingbirdTestsHost.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Array<MockingbirdTestsHost.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Array<MockingbirdTestsHost.NSObject>)()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Array<MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Array<MockingbirdTestsHost.NSObject>, Array<MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: Array<MockingbirdTestsHost.NSObject>, param2: Array<Foundation.NSObject>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func explicitMethod(param1: @escaping @autoclosure () -> Array<MockingbirdTestsHost.NSObject>, param2: @escaping @autoclosure () -> Array<Foundation.NSObject>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>))()
    }
  }

  public func explicitMethodWithParameterLabels() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>), (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>) -> (Array<MockingbirdTestsHost.NSObject>, Array<Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> [Foundation.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [Foundation.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [Foundation.NSObject])()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.NSObject], [Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> [MockingbirdTestsHost.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [MockingbirdTestsHost.NSObject])()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method(param1:param2:)`

  public func method(param1: [MockingbirdTestsHost.NSObject], param2: [Foundation.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func method(param1: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject], param2: @escaping @autoclosure () -> [Foundation.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]))()
    }
  }

  public func methodWithParameterLabels() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]), ([MockingbirdTestsHost.NSObject], [Foundation.NSObject]) -> ([MockingbirdTestsHost.NSObject], [Foundation.NSObject])>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ArrayTypes` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ArrayTypes.Protocol) -> ArrayTypesMock {
  return ArrayTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericConstraintsProtocol

public final class AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>: MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol, Mockingbird.Mock where ConstrainedType.EquatableType == Int, ConstrainedType.HashableType == String {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ConstrainedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericConstraintsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeGenericConstraintsProtocolMock, rhs: AssociatedTypeGenericConstraintsProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request(object:)`

  public func request(object: ConstrainedType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ConstrainedType) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func request(object: @escaping @autoclosure () -> ConstrainedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConstrainedType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ConstrainedType) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol<ConstrainedType>` concrete protocol mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeGenericConstraintsProtocol, ConstrainedType: MockingbirdTestsHost.AssociatedTypeProtocol>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType> {
  return AssociatedTypeGenericConstraintsProtocolMock<ConstrainedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericImplementer

public final class AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, Mockingbird.Mock where S.Element == EquatableType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(S.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `equatableTypeVariable`

  override public var equatableTypeVariable: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
  }

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: AssociatedTypeGenericImplementerMock, rhs: AssociatedTypeGenericImplementerMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodUsingEquatableType(equatable:)`

  public override func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn(equatable:)`

  public override func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingHashableType(hashable:)`

  public override func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hashable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S><EquatableType, S>` concrete class mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, EquatableType: Equatable, S: Sequence>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeGenericImplementerMock<EquatableType, S> {
  return AssociatedTypeGenericImplementerMock<EquatableType, S>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeImplementerProtocol

public final class AssociatedTypeImplementerProtocolMock: MockingbirdTestsHost.AssociatedTypeImplementerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerProtocolMock, rhs: AssociatedTypeImplementerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T.HashableType, T.HashableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.AssociatedTypeImplementerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol) -> AssociatedTypeImplementerProtocolMock {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeImplementer

public final class AssociatedTypeImplementerMock: MockingbirdTestsHost.AssociatedTypeImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerMock, rhs: AssociatedTypeImplementerMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request(object:)`

  public override func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func request<T: MockingbirdTestsHost.AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.AssociatedTypeImplementer` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.AssociatedTypeImplementer.Type) -> AssociatedTypeImplementerMock {
  return AssociatedTypeImplementerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeProtocol

public final class AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>: MockingbirdTestsHost.AssociatedTypeProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(HashableType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `equatableTypeVariable`

  public var equatableTypeVariable: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
  }

  public func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `equatableTypeVariable`

  public class var equatableTypeVariable: EquatableType {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> EquatableType)()
    }
  }

  public class func getEquatableTypeVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "equatableTypeVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> EquatableType, EquatableType>(mock: staticMock, invocation: invocation)
  }

  public static func ==(lhs: AssociatedTypeProtocolMock, rhs: AssociatedTypeProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodUsingEquatableTypeWithReturn(equatable:)`

  public static func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  public static func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`equatable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (EquatableType) -> EquatableType, EquatableType>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hashable`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (HashableType) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.AssociatedTypeProtocol<EquatableType, HashableType>` concrete protocol mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeProtocol, EquatableType: Equatable, HashableType: Hashable>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeProtocolMock<EquatableType, HashableType> {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeSelfReferencingProtocol

public final class AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence>: MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, Mockingbird.Mock where SequenceType.Element == AssociatedTypeSelfReferencingProtocolMock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(SequenceType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeSelfReferencingProtocolMock<SequenceType: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeSelfReferencingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeSelfReferencingProtocolMock, rhs: AssociatedTypeSelfReferencingProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request(array:)`

  public func request<T: Sequence>(array: T) -> Void where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func request<T: Sequence>(array: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> where T.Element == AssociatedTypeSelfReferencingProtocolMock {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(array:)`

  public func request(array: SequenceType) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`array`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (SequenceType) -> Void {
      concreteImplementation(`array`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func request(array: @escaping @autoclosure () -> SequenceType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`array`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(array:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SequenceType) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request(object: AssociatedTypeSelfReferencingProtocolMock) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AssociatedTypeSelfReferencingProtocolMock) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func request(object: @escaping @autoclosure () -> AssociatedTypeSelfReferencingProtocolMock) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AssociatedTypeSelfReferencingProtocolMock) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AssociatedTypeSelfReferencingProtocolMock) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol<SequenceType>` concrete protocol mock instance.
public func mock<MockType: MockingbirdTestsHost.AssociatedTypeSelfReferencingProtocol, SequenceType: Sequence>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> AssociatedTypeSelfReferencingProtocolMock<SequenceType> {
  return AssociatedTypeSelfReferencingProtocolMock<SequenceType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Bird

public final class BirdMock: MockingbirdTestsHost.Bird, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      BirdMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `canFly`

  public var canFly: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getCanFly() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "canFly.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: BirdMock, rhs: BirdMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `canEat(_:)`

  public func canEat<T>(_ object: T) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "canEat(_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func canEat<T>(_ object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "canEat(_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `chirp(volume:)`

  public func chirp(volume: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "chirp(volume:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`volume`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`volume`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func chirp(volume: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`volume`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "chirp(volume:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `eat(_:)`

  public func eat<T>(_ object: T) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "eat(_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func eat<T>(_ object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "eat(_:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fly()`

  public func fly() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "fly() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func fly() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "fly() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.Bird` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Bird.Protocol) -> BirdMock {
  return BirdMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `childInstanceVariable`

  public var childInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childPrivateSetterInstanceVariable`

  public var childPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childPrivateSetterStaticVariable`

  public class var childPrivateSetterStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childStaticVariable`

  public class var childStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  public static func ==(lhs: ChildProtocolMock, rhs: ChildProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func childTrivialStaticMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ChildProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ChildProtocol.Protocol) -> ChildProtocolMock {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `childClassVariable`

  override public class var childClassVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getChildClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childComputedInstanceVariable`

  override public var childComputedInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childStoredFileprivateSetterInstanceVariable`

  override public var childStoredFileprivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childStoredInstanceVariable`

  override public var childStoredInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getChildStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setChildStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childStoredPrivateSetterInstanceVariable`

  override public var childStoredPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getChildStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredFileprivateSetterInstanceVariable`

  override public var grandparentStoredFileprivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredInstanceVariable`

  override public var grandparentStoredInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredPrivateSetterInstanceVariable`

  override public var grandparentStoredPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentStoredFileprivateSetterInstanceVariable`

  override public var parentStoredFileprivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentStoredInstanceVariable`

  override public var parentStoredInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentStoredPrivateSetterInstanceVariable`

  override public var parentStoredPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: ChildMock, rhs: ChildMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `childParameterizedClassMethod(param1:_:)`

  public override static func childParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childParameterizedInstanceMethod(param1:_:)`

  public override func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `childTrivialClassMethod()`

  public override static func childTrivialClassMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func childTrivialClassMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `childTrivialInstanceMethod()`

  public override func childTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.Child` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Child.Type) -> ChildMock {
  return ChildMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClassType

public final class ClassTypeMock: MockingbirdTestsHost.ClassType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ClassTypeMock, rhs: ClassTypeMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ClassType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ClassType.Type) -> ClassTypeMock {
  return ClassTypeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClosureParametersProtocol

public final class ClosureParametersProtocolMock: MockingbirdTestsHost.ClosureParametersProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClosureParametersProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ClosureParametersProtocolMock, rhs: ClosureParametersProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @autoclosure () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func autoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @autoclosure () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func autoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@autoclosure () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping @autoclosure () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func escapingParameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func escapingParameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping (Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func escapingTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func escapingTrivialReturningVoidClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping () -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedClosure(block:)`

  public func parameterizedClosure(block: (Bool) -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: (Bool) -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(Bool) -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool) -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialClosure(block:)`

  public func trivialClosure(block: () -> Void) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func trivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Void) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: () -> Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> Bool>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func trivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`block`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ClosureParametersProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ClosureParametersProtocol.Protocol) -> ClosureParametersProtocolMock {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ConvenienceInitializerClass

public final class ConvenienceInitializerClassMock: MockingbirdTestsHost.ConvenienceInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConvenienceInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(param1: Bool, param2: Int, __file: StaticString = #file, __line: UInt = #line) -> ConvenienceInitializerClassMock {
      let mock: ConvenienceInitializerClassMock = ConvenienceInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: ConvenienceInitializerClassMock, rhs: ConvenienceInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init(param1:param2:)`

  public required override init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ConvenienceInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ConvenienceInitializerClass.Type) -> ConvenienceInitializerClassMock.InitializerProxy.Type {
  return ConvenienceInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked DeclarationAttributesClass

public final class DeclarationAttributesClassMock: MockingbirdTestsHost.DeclarationAttributesClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeclarationAttributesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `availableVariable`

  @available(iOSMac 10.10, *)
  override public var availableVariable: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  @available(iOSMac 10.10, *)
  public func getAvailableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: DeclarationAttributesClassMock, rhs: DeclarationAttributesClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `availableMethod(param:)`

  @available(iOSMac 10.10, *)
  public override func availableMethod(param: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableMethod(param:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  @available(iOSMac 10.10, *)
  public func availableMethod(param: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableMethod(param:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `multipleAttributesMethod(param:)`

  @available(iOSMac 10.10, *)
  public override func multipleAttributesMethod(param: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multipleAttributesMethod(param:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  @available(iOSMac 10.10, *)
  public func multipleAttributesMethod(param: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multipleAttributesMethod(param:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.DeclarationAttributesClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DeclarationAttributesClass.Type) -> DeclarationAttributesClassMock {
  return DeclarationAttributesClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DeclarationAttributesProtocol

public final class DeclarationAttributesProtocolMock: MockingbirdTestsHost.DeclarationAttributesProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeclarationAttributesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `availableVariable`

  @available(iOSMac 10.10, *)
  public var availableVariable: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  @available(iOSMac 10.10, *)
  public func getAvailableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: DeclarationAttributesProtocolMock, rhs: DeclarationAttributesProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `availableMethod(param:)`

  @available(iOSMac 10.10, *)
  public func availableMethod(param: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableMethod(param:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  @available(iOSMac 10.10, *)
  public func availableMethod(param: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "availableMethod(param:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.DeclarationAttributesProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DeclarationAttributesProtocol.Protocol) -> DeclarationAttributesProtocolMock {
  return DeclarationAttributesProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DefaultArgumentValuesClass

public final class DefaultArgumentValuesClassMock: MockingbirdTestsHost.DefaultArgumentValuesClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: DefaultArgumentValuesClassMock, rhs: DefaultArgumentValuesClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method(param1:param2:)`

  public override func method(param1: String, param2: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func method(param1: @escaping @autoclosure () -> String, param2: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.DefaultArgumentValuesClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DefaultArgumentValuesClass.Type) -> DefaultArgumentValuesClassMock {
  return DefaultArgumentValuesClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DefaultArgumentValuesProtocol

public final class DefaultArgumentValuesProtocolMock: MockingbirdTestsHost.DefaultArgumentValuesProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultArgumentValuesProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: DefaultArgumentValuesProtocolMock, rhs: DefaultArgumentValuesProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method(param1:param2:)`

  public func method(param1: String, param2: [MockingbirdTestsHost.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, [MockingbirdTestsHost.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func method(param1: @escaping @autoclosure () -> String, param2: @escaping @autoclosure () -> [MockingbirdTestsHost.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, [MockingbirdTestsHost.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.DefaultArgumentValuesProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DefaultArgumentValuesProtocol.Protocol) -> DefaultArgumentValuesProtocolMock {
  return DefaultArgumentValuesProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DictionaryCollection

public final class DictionaryCollectionMock: MockingbirdTestsHost.DictionaryCollection, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryCollectionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: DictionaryCollectionMock, rhs: DictionaryCollectionMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method(objects:)`

  public func method(objects: [String: String]) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([String: String]) -> Bool {
      return concreteImplementation(`objects`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func method(objects: @escaping @autoclosure () -> [String: String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String: String]) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(objects:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String: String]) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.DictionaryCollection` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DictionaryCollection.Protocol) -> DictionaryCollectionMock {
  return DictionaryCollectionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DictionaryTypes

public final class DictionaryTypesMock: MockingbirdTestsHost.DictionaryTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DictionaryTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `anotherVariable`

  public var anotherVariable: [Foundation.URL: Foundation.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.URL: Foundation.NSObject])()
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitAnotherVariable`

  public var explicitAnotherVariable: Dictionary<Foundation.URL, Foundation.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<Foundation.URL, Foundation.NSObject>)()
    }
  }

  public func getExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitVariable`

  public var explicitVariable: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>)()
    }
  }

  public func getExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalAnotherVariable`

  public var optionalAnotherVariable: [Foundation.URL: Foundation.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [Foundation.URL: Foundation.NSObject?])()
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [Foundation.URL: Foundation.NSObject?], [Foundation.URL: Foundation.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalExplicitAnotherVariable`

  public var optionalExplicitAnotherVariable: Dictionary<Foundation.URL, Foundation.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<Foundation.URL, Foundation.NSObject?>)()
    }
  }

  public func getOptionalExplicitAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject?>, Dictionary<Foundation.URL, Foundation.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalExplicitVariable`

  public var optionalExplicitVariable: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?> {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>)()
    }
  }

  public func getOptionalExplicitVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalExplicitVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject?>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalVariable`

  public var optionalVariable: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?])()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject?]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variable`

  public var variable: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject])()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: DictionaryTypesMock, rhs: DictionaryTypesMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Dictionary<Foundation.URL, Foundation.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Dictionary<Foundation.URL, Foundation.NSObject>)()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<Foundation.URL, Foundation.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<Foundation.URL, Foundation.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod()`

  public func explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject> {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>)()
    }
  }

  public func explicitMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod() -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethod(param1:param2:)`

  public func explicitMethod(param1: Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, param2: Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func explicitMethod(param1: @escaping @autoclosure () -> Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, param2: @escaping @autoclosure () -> Dictionary<Foundation.URL, Foundation.NSObject>) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `explicitMethodWithParameterLabels()`

  public func explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>))()
    }
  }

  public func explicitMethodWithParameterLabels() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "explicitMethodWithParameterLabels() -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>), (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>) -> (Dictionary<MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject>, Dictionary<Foundation.URL, Foundation.NSObject>)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> [Foundation.URL: Foundation.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [Foundation.URL: Foundation.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [Foundation.URL: Foundation.NSObject])()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [Foundation.URL: Foundation.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [Foundation.URL: Foundation.NSObject], [Foundation.URL: Foundation.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject])()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method(param1:param2:)`

  public func method(param1: [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], param2: [Foundation.URL: Foundation.NSObject]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func method(param1: @escaping @autoclosure () -> [MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], param2: @escaping @autoclosure () -> [Foundation.URL: Foundation.NSObject]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]))()
    }
  }

  public func methodWithParameterLabels() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]), ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject]) -> ([MockingbirdTestsHost.URL: MockingbirdTestsHost.NSObject], [Foundation.URL: Foundation.NSObject])>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.DictionaryTypes` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.DictionaryTypes.Protocol) -> DictionaryTypesMock {
  return DictionaryTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked EmptyInitializerClass

public final class EmptyInitializerClassMock: MockingbirdTestsHost.EmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> EmptyInitializerClassMock {
      let mock: EmptyInitializerClassMock = EmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: EmptyInitializerClassMock, rhs: EmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init()`

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.EmptyInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.EmptyInitializerClass.Type) -> EmptyInitializerClassMock.InitializerProxy.Type {
  return EmptyInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked EmptyInitializerProtocol

public final class EmptyInitializerProtocolMock: MockingbirdTestsHost.EmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: EmptyInitializerProtocolMock, rhs: EmptyInitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init()`

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.EmptyInitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol) -> EmptyInitializerProtocolMock {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ExtendableProtocol

public final class ExtendableProtocolMock: MockingbirdTestsHost.ExtendableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `anotherExtendedVariable`

  public var anotherExtendedVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `baseVariable`

  public var baseVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `extendedVariable`

  public var extendedVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getExtendedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: ExtendableProtocolMock, rhs: ExtendableProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func anotherTrivialExtendedMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param1`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param1`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialBaseMethod()`

  public func trivialBaseMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func trivialBaseMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func trivialExtendedMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ExtendableProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ExtendableProtocol.Protocol) -> ExtendableProtocolMock {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableEmptyInitializerClass

public final class FailableEmptyInitializerClassMock: MockingbirdTestsHost.FailableEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableEmptyInitializerClassMock? {
      let mock: FailableEmptyInitializerClassMock? = FailableEmptyInitializerClassMock()
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: FailableEmptyInitializerClassMock, rhs: FailableEmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init()`

  public required override init?() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableEmptyInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableEmptyInitializerClass.Type) -> FailableEmptyInitializerClassMock.InitializerProxy.Type {
  return FailableEmptyInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableEmptyInitializerProtocol

public final class FailableEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableEmptyInitializerProtocolMock, rhs: FailableEmptyInitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init()`

  public required init?() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableEmptyInitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol) -> FailableEmptyInitializerProtocolMock {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableParameterizedInitializerClass

public final class FailableParameterizedInitializerClassMock: MockingbirdTestsHost.FailableParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(param1: Bool, param2: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableParameterizedInitializerClassMock? {
      let mock: FailableParameterizedInitializerClassMock? = FailableParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: FailableParameterizedInitializerClassMock, rhs: FailableParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init(param1:param2:)`

  public required override init?(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableParameterizedInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableParameterizedInitializerClass.Type) -> FailableParameterizedInitializerClassMock.InitializerProxy.Type {
  return FailableParameterizedInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableParameterizedInitializerProtocol

public final class FailableParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableParameterizedInitializerProtocolMock, rhs: FailableParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init(param1:param2:)`

  public required init?(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableParameterizedInitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol) -> FailableParameterizedInitializerProtocolMock {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerClass

public final class FailableUnwrappedEmptyInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedEmptyInitializerClassMock {
      let mock: FailableUnwrappedEmptyInitializerClassMock = FailableUnwrappedEmptyInitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: FailableUnwrappedEmptyInitializerClassMock, rhs: FailableUnwrappedEmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init()`

  public required override init!() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass.Type) -> FailableUnwrappedEmptyInitializerClassMock.InitializerProxy.Type {
  return FailableUnwrappedEmptyInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerProtocol

public final class FailableUnwrappedEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedEmptyInitializerProtocolMock, rhs: FailableUnwrappedEmptyInitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init()`

  public required init!() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol) -> FailableUnwrappedEmptyInitializerProtocolMock {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerClass

public final class FailableUnwrappedParameterizedInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(param1: Bool, param2: Int, __file: StaticString = #file, __line: UInt = #line) -> FailableUnwrappedParameterizedInitializerClassMock {
      let mock: FailableUnwrappedParameterizedInitializerClassMock = FailableUnwrappedParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: FailableUnwrappedParameterizedInitializerClassMock, rhs: FailableUnwrappedParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init(param1:param2:)`

  public required override init!(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass.Type) -> FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy.Type {
  return FailableUnwrappedParameterizedInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerProtocol

public final class FailableUnwrappedParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedParameterizedInitializerProtocolMock, rhs: FailableUnwrappedParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init(param1:param2:)`

  public required init!(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol) -> FailableUnwrappedParameterizedInitializerProtocolMock {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  public static func ==(lhs: GrandparentProtocolMock, rhs: GrandparentProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.GrandparentProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.GrandparentProtocol.Protocol) -> GrandparentProtocolMock {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredFileprivateSetterInstanceVariable`

  override public var grandparentStoredFileprivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredInstanceVariable`

  override public var grandparentStoredInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredPrivateSetterInstanceVariable`

  override public var grandparentStoredPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: GrandparentMock, rhs: GrandparentMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.Grandparent` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Grandparent.Type) -> GrandparentMock {
  return GrandparentMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritedTypeQualificationProtocolGenericImplementer

public final class InheritedTypeQualificationProtocolGenericImplementerMock<T>: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(T.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolGenericImplementerMock<T>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InheritedTypeQualificationProtocolGenericImplementerMock, rhs: InheritedTypeQualificationProtocolGenericImplementerMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation(param:)`

  public override func lessQualifiedImplementation(param: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation(param:)`

  public override func moreQualifiedImplementation(param: ScopedType) -> ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T><T>` concrete class mock instance.
public func mock<MockType: MockingbirdTestsHost.InheritedTypeQualificationProtocolGenericImplementer<T>, T>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> InheritedTypeQualificationProtocolGenericImplementerMock<T> {
  return InheritedTypeQualificationProtocolGenericImplementerMock<T>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritedTypeQualificationProtocolImplementer

public final class InheritedTypeQualificationProtocolImplementerMock: MockingbirdTestsHost.InheritedTypeQualificationProtocolImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InheritedTypeQualificationProtocolImplementerMock, rhs: InheritedTypeQualificationProtocolImplementerMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation(param:)`

  public override func lessQualifiedImplementation(param: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation(param:)`

  public override func moreQualifiedImplementation(param: ScopedType) -> ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InheritedTypeQualificationProtocolImplementer` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InheritedTypeQualificationProtocolImplementer.Type) -> InheritedTypeQualificationProtocolImplementerMock {
  return InheritedTypeQualificationProtocolImplementerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InheritedTypeQualificationProtocol

public final class InheritedTypeQualificationProtocolMock<ScopedType>: MockingbirdTestsHost.InheritedTypeQualificationProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(ScopedType.self)"].joined(separator: ",")
    let staticMockIdentifier = "InheritedTypeQualificationProtocolMock<ScopedType>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InheritedTypeQualificationProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InheritedTypeQualificationProtocolMock, rhs: InheritedTypeQualificationProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `lessQualifiedImplementation(param:)`

  public func lessQualifiedImplementation(param: MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.UnscopedType?)()
    }
  }

  public func lessQualifiedImplementation(param: @escaping @autoclosure () -> MockingbirdTestsHost.UnscopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "lessQualifiedImplementation(param:) -> MockingbirdTestsHost.UnscopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.UnscopedType) -> MockingbirdTestsHost.UnscopedType?, MockingbirdTestsHost.UnscopedType?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `moreQualifiedImplementation(param:)`

  public func moreQualifiedImplementation(param: ScopedType) -> ScopedType? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (ScopedType) -> ScopedType? {
      return concreteImplementation(`param`)
    } else {
      return (implementation as! () -> ScopedType?)()
    }
  }

  public func moreQualifiedImplementation(param: @escaping @autoclosure () -> ScopedType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "moreQualifiedImplementation(param:) -> ScopedType?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (ScopedType) -> ScopedType?, ScopedType?>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InheritedTypeQualificationProtocol<ScopedType>` concrete protocol mock instance.
public func mock<MockType: MockingbirdTestsHost.InheritedTypeQualificationProtocol, ScopedType>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> InheritedTypeQualificationProtocolMock<ScopedType> {
  return InheritedTypeQualificationProtocolMock<ScopedType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InitializerClass

public final class InitializerClassMock: MockingbirdTestsHost.InitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(param1: Bool, _ param2: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param1: `param1`, `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(param: Bool, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock? {
      let mock: InitializerClassMock? = InitializerClassMock(param: `param`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(param: Int, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(param: String?, __file: StaticString = #file, __line: UInt = #line) -> InitializerClassMock {
      let mock: InitializerClassMock = InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }

    public static func initialize(param: String, __file: StaticString = #file, __line: UInt = #line) throws -> InitializerClassMock {
      let mock: InitializerClassMock = try InitializerClassMock(param: `param`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: InitializerClassMock, rhs: InitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init()`

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param1:_:)`

  public required override init(param1: Bool, _ param2: Int) {
    super.init(param1: `param1`, `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required override init?(param: Bool) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required override init!(param: Int) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required init(param: String?) {
    super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required override init(param: String) throws {
    try super.init(param: `param`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InitializerClass.Type) -> InitializerClassMock.InitializerProxy.Type {
  return InitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked InitializerProtocol

public final class InitializerProtocolMock: MockingbirdTestsHost.InitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InitializerProtocolMock, rhs: InitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init()`

  public required init() {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param1:_:)`

  public required init(param1: Bool, _ param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required init?(param: Bool) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required init!(param: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `init(param:)`

  public required init(param: String) throws {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InitializerProtocol.Protocol) -> InitializerProtocolMock {
  return InitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InoutClass

public final class InoutClassMock: MockingbirdTestsHost.InoutClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutClassMock, rhs: InoutClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `parameterizedMethod(object:)`

  public override func parameterizedMethod(object: inout String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InoutClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InoutClass.Type) -> InoutClassMock {
  return InoutClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked InoutProtocol

public final class InoutProtocolMock: MockingbirdTestsHost.InoutProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutProtocolMock, rhs: InoutProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `parameterizedMethod(object:)`

  public func parameterizedMethod(object: inout String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (inout String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.InoutProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.InoutProtocol.Protocol) -> InoutProtocolMock {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ModuleScopedAssociatedTypeProtocol

public final class ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: ModuleScopedAssociatedTypeProtocol>: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, Mockingbird.Mock where Data.Element == MockingbirdTestsHost.NSObject {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(Element.self)", "\(Subelement.self)", "\(Data.self)"].joined(separator: ",")
    let staticMockIdentifier = "ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data: ModuleScopedAssociatedTypeProtocol>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedAssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ModuleScopedAssociatedTypeProtocolMock, rhs: ModuleScopedAssociatedTypeProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol<Element, Subelement, Data>` concrete protocol mock instance.
public func mock<MockType: MockingbirdTestsHost.ModuleScopedAssociatedTypeProtocol, Element, Subelement, Data: ModuleScopedAssociatedTypeProtocol>(file: StaticString = #file, line: UInt = #line, _ type: MockType.Type) -> ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data> {
  return ModuleScopedAssociatedTypeProtocolMock<Element, Subelement, Data>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ModuleScopedTypealiasedProtocol

public final class ModuleScopedTypealiasedProtocolMock: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ModuleScopedTypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ModuleScopedTypealiasedProtocolMock, rhs: ModuleScopedTypealiasedProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: T?) -> T? where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T?) -> T? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T?)()
    }
  }

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: @escaping @autoclosure () -> T?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?> where T.Element == Foundation.NSObjectProtocol?, T.Subelement == MockingbirdTestsHost.NSObject? {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T?) -> T?, T?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `genericRequest(object:)`

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: T) -> T where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T)()
    }
  }

  public func genericRequest<T: MockingbirdTestsHost.NSObjectProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T> where T.Element == Foundation.NSObjectProtocol, T.Subelement == MockingbirdTestsHost.NSObject {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "genericRequest(object:) -> T", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (T) -> T, T>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request(object: Foundation.NSObject?) -> Foundation.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject?) -> Foundation.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject?)()
    }
  }

  public func request(object: @escaping @autoclosure () -> Foundation.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject?) -> Foundation.NSObject?, Foundation.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request(object: Foundation.NSObject) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Foundation.NSObject) -> Foundation.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func request(object: @escaping @autoclosure () -> Foundation.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Foundation.NSObject) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request(object: MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject?", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject? {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject?)()
    }
  }

  public func request(object: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject?", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject?) -> MockingbirdTestsHost.NSObject?, MockingbirdTestsHost.NSObject?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(object:)`

  public func request(object: MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> MockingbirdTestsHost.NSObject)()
    }
  }

  public func request(object: @escaping @autoclosure () -> MockingbirdTestsHost.NSObject) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(object:) -> MockingbirdTestsHost.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.NSObject) -> MockingbirdTestsHost.NSObject, MockingbirdTestsHost.NSObject>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ModuleScopedTypealiasedProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ModuleScopedTypealiasedProtocol.Protocol) -> ModuleScopedTypealiasedProtocolMock {
  return ModuleScopedTypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NonExtendableClass

public final class NonExtendableClassMock: MockingbirdTestsHost.NonExtendableClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `baseVariable`

  override public var baseVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getBaseVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: NonExtendableClassMock, rhs: NonExtendableClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `trivialBaseMethod()`

  public override func trivialBaseMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func trivialBaseMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.NonExtendableClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.NonExtendableClass.Type) -> NonExtendableClassMock {
  return NonExtendableClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OptionalsProtocol

public final class OptionalsProtocolMock: MockingbirdTestsHost.OptionalsProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OptionalsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `multiUnwrappedOptionalVariable`

  public var multiUnwrappedOptionalVariable: Bool???! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multiUnwrappedOptionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool???)()
    }
  }

  public func getMultiUnwrappedOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "multiUnwrappedOptionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalVariable`

  public var optionalVariable: Bool? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool?)()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool?, Bool?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool?, Bool?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unwrappedOptionalVariable`

  public var unwrappedOptionalVariable: Bool! {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "unwrappedOptionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getUnwrappedOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "unwrappedOptionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: OptionalsProtocolMock, rhs: OptionalsProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `methodWithMultiOptionalParameter(param:)`

  public func methodWithMultiOptionalParameter(param: Bool???) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool???) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithMultiOptionalParameter(param: @escaping @autoclosure () -> Bool???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiOptionalReturn()`

  public func methodWithMultiOptionalReturn() -> Bool??? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalReturn() -> Bool???", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool??? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool???)()
    }
  }

  public func methodWithMultiOptionalReturn() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalReturn() -> Bool???", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiOptionalVariadicParameter(param:)`

  public func methodWithMultiOptionalVariadicParameter(param: Bool???...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalVariadicParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool???]) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithMultiOptionalVariadicParameter(param: @escaping @autoclosure () -> [Bool???]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalVariadicParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func methodWithMultiOptionalVariadicParameter(param: Bool???...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiOptionalVariadicParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool???]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalCompoundParameter(param:)`

  public func methodWithMultiUnwrappedOptionalCompoundParameter(param: (Bool?, Int)???!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalCompoundParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((Bool?, Int)???) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithMultiUnwrappedOptionalCompoundParameter(param: @escaping @autoclosure () -> (Bool?, Int)???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalCompoundParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalCompoundReturn()`

  public func methodWithMultiUnwrappedOptionalCompoundReturn() -> (Bool?, Int)???! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalCompoundReturn() -> (Bool?, Int)???!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Bool?, Int)??? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Bool?, Int)???)()
    }
  }

  public func methodWithMultiUnwrappedOptionalCompoundReturn() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int)???, (Bool?, Int)???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalCompoundReturn() -> (Bool?, Int)???!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int)???, (Bool?, Int)???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalParameter(param:)`

  public func methodWithMultiUnwrappedOptionalParameter(param: Bool???!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool???) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithMultiUnwrappedOptionalParameter(param: @escaping @autoclosure () -> Bool???) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool???) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithMultiUnwrappedOptionalReturn()`

  public func methodWithMultiUnwrappedOptionalReturn() -> Bool???! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalReturn() -> Bool???!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool??? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool???)()
    }
  }

  public func methodWithMultiUnwrappedOptionalReturn() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithMultiUnwrappedOptionalReturn() -> Bool???!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool???, Bool???>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalParameter(param:)`

  public func methodWithOptionalParameter(param: Bool?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool?) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithOptionalParameter(param: @escaping @autoclosure () -> Bool?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalReturn()`

  public func methodWithOptionalReturn() -> Bool? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalReturn() -> Bool?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool?)()
    }
  }

  public func methodWithOptionalReturn() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool?, Bool?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalReturn() -> Bool?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool?, Bool?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithOptionalVariadicParameter(param:)`

  public func methodWithOptionalVariadicParameter(param: Bool?...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalVariadicParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool?]) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithOptionalVariadicParameter(param: @escaping @autoclosure () -> [Bool?]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalVariadicParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func methodWithOptionalVariadicParameter(param: Bool?...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithOptionalVariadicParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool?]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedCompoundParameter(param:)`

  public func methodWithUnwrappedCompoundParameter(param: (Bool?, Int)!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedCompoundParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((Bool?, Int)) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithUnwrappedCompoundParameter(param: @escaping @autoclosure () -> (Bool?, Int)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedCompoundParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((Bool?, Int)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedCompoundReturn()`

  public func methodWithUnwrappedCompoundReturn() -> (Bool?, Int)! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedCompoundReturn() -> (Bool?, Int)!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Bool?, Int) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Bool?, Int))()
    }
  }

  public func methodWithUnwrappedCompoundReturn() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int), (Bool?, Int)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedCompoundReturn() -> (Bool?, Int)!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Bool?, Int), (Bool?, Int)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedParameter(param:)`

  public func methodWithUnwrappedParameter(param: Bool!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedParameter(param:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func methodWithUnwrappedParameter(param: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedParameter(param:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithUnwrappedReturn()`

  public func methodWithUnwrappedReturn() -> Bool! {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedReturn() -> Bool!", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func methodWithUnwrappedReturn() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithUnwrappedReturn() -> Bool!", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.OptionalsProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.OptionalsProtocol.Protocol) -> OptionalsProtocolMock {
  return OptionalsProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OverloadedMethodsClass

public final class OverloadedMethodsClassMock: MockingbirdTestsHost.OverloadedMethodsClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: OverloadedMethodsClassMock, rhs: OverloadedMethodsClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `overloadedParameters(param1:param2:)`

  public override func overloadedParameters(param1: Bool, param2: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters(param1:param2:)`

  public override func overloadedParameters(param1: Int, param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType()`

  public override func overloadedReturnType() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func overloadedReturnType() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType()`

  public override func overloadedReturnType() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  public func overloadedReturnType() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.OverloadedMethodsClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.OverloadedMethodsClass.Type) -> OverloadedMethodsClassMock {
  return OverloadedMethodsClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked OverloadedMethodsProtocol

public final class OverloadedMethodsProtocolMock: MockingbirdTestsHost.OverloadedMethodsProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: OverloadedMethodsProtocolMock, rhs: OverloadedMethodsProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: Bool, param2: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: Int, param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType()`

  public func overloadedReturnType() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func overloadedReturnType() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `overloadedReturnType()`

  public func overloadedReturnType() -> Int {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  public func overloadedReturnType() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.OverloadedMethodsProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol) -> OverloadedMethodsProtocolMock {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParameterizedInitializerClass

public final class ParameterizedInitializerClassMock: MockingbirdTestsHost.ParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(param1: Bool, param2: Int, __file: StaticString = #file, __line: UInt = #line) -> ParameterizedInitializerClassMock {
      let mock: ParameterizedInitializerClassMock = ParameterizedInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: ParameterizedInitializerClassMock, rhs: ParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init(param1:param2:)`

  public required override init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ParameterizedInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ParameterizedInitializerClass.Type) -> ParameterizedInitializerClassMock.InitializerProxy.Type {
  return ParameterizedInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked ParameterizedInitializerProtocol

public final class ParameterizedInitializerProtocolMock: MockingbirdTestsHost.ParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ParameterizedInitializerProtocolMock, rhs: ParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `init(param1:param2:)`

  public required init(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ParameterizedInitializerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol) -> ParameterizedInitializerProtocolMock {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  public static func ==(lhs: ParentProtocolMock, rhs: ParentProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ParentProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ParentProtocol.Protocol) -> ParentProtocolMock {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredFileprivateSetterInstanceVariable`

  override public var grandparentStoredFileprivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredInstanceVariable`

  override public var grandparentStoredInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getGrandparentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setGrandparentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentStoredPrivateSetterInstanceVariable`

  override public var grandparentStoredPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getGrandparentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public class func getParentClassVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentStoredFileprivateSetterInstanceVariable`

  override public var parentStoredFileprivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredFileprivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredFileprivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentStoredInstanceVariable`

  override public var parentStoredInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getParentStoredInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setParentStoredInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredInstanceVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentStoredPrivateSetterInstanceVariable`

  override public var parentStoredPrivateSetterInstanceVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getParentStoredPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentStoredPrivateSetterInstanceVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: ParentMock, rhs: ParentMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: staticMock, invocation: invocation)
  }

  // MARK: Mocked `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.Parent` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Parent.Type) -> ParentMock {
  return ParentMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked RequiredInitializerClass

public final class RequiredInitializerClassMock: MockingbirdTestsHost.RequiredInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RequiredInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(param1: Bool, param2: Int, __file: StaticString = #file, __line: UInt = #line) -> RequiredInitializerClassMock {
      let mock: RequiredInitializerClassMock = RequiredInitializerClassMock(param1: `param1`, param2: `param2`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: RequiredInitializerClassMock, rhs: RequiredInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mocked `init(param1:param2:)`

  public required init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.RequiredInitializerClass` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.RequiredInitializerClass.Type) -> RequiredInitializerClassMock.InitializerProxy.Type {
  return RequiredInitializerClassMock.InitializerProxy.self
}

// MARK: - Mocked ServiceRepository

public final class ServiceRepositoryMock: MockingbirdTestsHost.ServiceRepository, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ServiceRepositoryMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `testManager`

  public var testManager: MockingbirdTestsHost.TestManager {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.TestManager)()
    }
  }

  public func getTestManager() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testManager.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestManager, MockingbirdTestsHost.TestManager>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: ServiceRepositoryMock, rhs: ServiceRepositoryMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `MockingbirdTestsHost.ServiceRepository` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.ServiceRepository.Protocol) -> ServiceRepositoryMock {
  return ServiceRepositoryMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TestCase

public final class TestCaseMock: MockingbirdTestsHost.TestCase, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestCaseMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TestCaseMock, rhs: TestCaseMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `run(description:)`

  public func run(description: String) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "run(description:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`description`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (String) -> Bool {
      return concreteImplementation(`description`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func run(description: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`description`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "run(description:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.TestCase` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TestCase.Protocol) -> TestCaseMock {
  return TestCaseMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TestManager

public final class TestManagerMock: MockingbirdTestsHost.TestManager, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestManagerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `currentTest`

  public var currentTest: MockingbirdTestsHost.Test {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.Test)()
    }
  }

  public func getCurrentTest() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "currentTest.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.Test, MockingbirdTestsHost.Test>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: TestManagerMock, rhs: TestManagerMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `stopTests()`

  public func stopTests() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "stopTests() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func stopTests() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "stopTests() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.TestManager` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TestManager.Protocol) -> TestManagerMock {
  return TestManagerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Test

public final class TestMock: MockingbirdTestsHost.Test, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TestMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `testCase`

  public var testCase: MockingbirdTestsHost.TestCase {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> MockingbirdTestsHost.TestCase)()
    }
  }

  public func getTestCase() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "testCase.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> MockingbirdTestsHost.TestCase, MockingbirdTestsHost.TestCase>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: TestMock, rhs: TestMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `add(testCase:)`

  public func add(testCase: MockingbirdTestsHost.TestCase) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "add(testCase:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`testCase`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (MockingbirdTestsHost.TestCase) -> Bool {
      return concreteImplementation(`testCase`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func add(testCase: @escaping @autoclosure () -> MockingbirdTestsHost.TestCase) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TestCase) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`testCase`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "add(testCase:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (MockingbirdTestsHost.TestCase) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.Test` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Test.Protocol) -> TestMock {
  return TestMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TopLevelType

public final class TopLevelTypeMock: MockingbirdTestsHost.TopLevelType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TopLevelTypeMock, rhs: TopLevelTypeMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `topLevelMethod(param1:param2:)`

  public override func topLevelMethod(param1: SecondLevelType, param2: SecondLevelType.ThirdLevelType) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: - Mocked SecondLevelType
  
  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }
  
    public static func ==(lhs: SecondLevelTypeMock, rhs: SecondLevelTypeMock) -> Bool {
      return true
    }
  
    fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
      super.init()
      Mockingbird.checkVersion(for: self)
      self.sourceLocation = sourceLocation
    }
  
    // MARK: Mocked `secondLevelMethod(param1:param2:)`
  
    public override func secondLevelMethod(param1: TopLevelType, param2: ThirdLevelType) -> Bool {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (TopLevelType, ThirdLevelType) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else {
        return (implementation as! () -> Bool)()
      }
    }
  
    public func secondLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, ThirdLevelType) -> Bool, Bool> {
      let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: arguments)
      return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
    }
  
    // MARK: - Mocked ThirdLevelInheritingTopLevelType
    
    public final class ThirdLevelInheritingTopLevelTypeMock: ThirdLevelInheritingTopLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingTopLevelTypeMock, rhs: ThirdLevelInheritingTopLevelTypeMock) -> Bool {
        return true
      }
    
      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }
    
      // MARK: Mocked `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> TopLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> TopLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> TopLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> TopLevelType)()
        }
      }
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> TopLevelType, TopLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> TopLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> TopLevelType, TopLevelType>(mock: self, invocation: invocation)
      }
    
      // MARK: Mocked `topLevelMethod(param1:param2:)`
    
      public override func topLevelMethod(param1: SecondLevelType, param2: SecondLevelType.ThirdLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  
    // MARK: - Mocked ThirdLevelInheritingThirdLevelType
    
    public final class ThirdLevelInheritingThirdLevelTypeMock: ThirdLevelInheritingThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingThirdLevelTypeMock, rhs: ThirdLevelInheritingThirdLevelTypeMock) -> Bool {
        return true
      }
    
      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }
    
      // MARK: Mocked `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> ThirdLevelType)()
        }
      }
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ThirdLevelType, ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ThirdLevelType, ThirdLevelType>(mock: self, invocation: invocation)
      }
    
      // MARK: Mocked `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  
    // MARK: - Mocked ThirdLevelInheritingPartiallyQualifiedThirdLevelType
    
    public final class ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock: ThirdLevelInheritingPartiallyQualifiedThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock, rhs: ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock) -> Bool {
        return true
      }
    
      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }
    
      // MARK: Mocked `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> ThirdLevelType)()
        }
      }
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ThirdLevelType, ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ThirdLevelType, ThirdLevelType>(mock: self, invocation: invocation)
      }
    
      // MARK: Mocked `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  
    // MARK: - Mocked ThirdLevelInheritingFullyQualifiedThirdLevelType
    
    public final class ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock: ThirdLevelInheritingFullyQualifiedThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock, rhs: ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock) -> Bool {
        return true
      }
    
      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }
    
      // MARK: Mocked `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> ThirdLevelType {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> ThirdLevelType {
          return concreteImplementation()
        } else {
          return (implementation as! () -> ThirdLevelType)()
        }
      }
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ThirdLevelType, ThirdLevelType> {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> ThirdLevelType", arguments: [])
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ThirdLevelType, ThirdLevelType>(mock: self, invocation: invocation)
      }
    
      // MARK: Mocked `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  
    // MARK: - Mocked ThirdLevelType
    
    public final class ThirdLevelTypeMock: ThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelTypeMock, rhs: ThirdLevelTypeMock) -> Bool {
        return true
      }
    
      fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
        super.init()
        Mockingbird.checkVersion(for: self)
        self.sourceLocation = sourceLocation
      }
    
      // MARK: Mocked `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (TopLevelType, SecondLevelType) -> Bool, Bool>(mock: self, invocation: invocation)
      }
    }
  }
}

/// Create a source-attributed `MockingbirdTestsHost.TopLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.Type) -> TopLevelTypeMock {
  return TopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Create a source-attributed `SecondLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.Type) -> TopLevelTypeMock.SecondLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Create a source-attributed `ThirdLevelInheritingTopLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingTopLevelType.Type) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingTopLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Create a source-attributed `ThirdLevelInheritingThirdLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingThirdLevelType.Type) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Create a source-attributed `ThirdLevelInheritingPartiallyQualifiedThirdLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingPartiallyQualifiedThirdLevelType.Type) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingPartiallyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Create a source-attributed `ThirdLevelInheritingFullyQualifiedThirdLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelInheritingFullyQualifiedThirdLevelType.Type) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelInheritingFullyQualifiedThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

/// Create a source-attributed `ThirdLevelType` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TopLevelType.SecondLevelType.ThirdLevelType.Type) -> TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock {
  return TopLevelTypeMock.SecondLevelTypeMock.ThirdLevelTypeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Tree

public final class TreeMock: MockingbirdTestsHost.Tree, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TreeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(with bird: MockingbirdTestsHost.Bird, __file: StaticString = #file, __line: UInt = #line) -> TreeMock {
      let mock: TreeMock = TreeMock(with: `bird`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  public static func ==(lhs: TreeMock, rhs: TreeMock) -> Bool {
    return true
  }

  // MARK: Mocked `drop(_:)`

  public override func drop(_ fruit: Fruit) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "drop(_:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`fruit`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Fruit) -> Void {
      concreteImplementation(`fruit`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func drop(_ fruit: @escaping @autoclosure () -> Fruit) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Fruit) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`fruit`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "drop(_:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Fruit) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `init(with:)`

  public required override init(with bird: MockingbirdTestsHost.Bird) {
    super.init(with: `bird`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(with:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`bird`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `shake()`

  public override func shake() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "shake() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func shake() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "shake() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: - Mocked Fruit
  
  public final class FruitMock: Fruit, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        FruitMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }
  
    public enum InitializerProxy {
      public static func initialize(size: Int, __file: StaticString = #file, __line: UInt = #line) -> FruitMock {
        let mock: FruitMock = FruitMock(size: `size`)
        mock.sourceLocation = SourceLocation(__file, __line)
        return mock
      }
    }
  
    public static func ==(lhs: FruitMock, rhs: FruitMock) -> Bool {
      return true
    }
  
    // MARK: Mocked `init(size:)`
  
    public required override init(size: Int) {
      super.init(size: `size`)
      Mockingbird.checkVersion(for: self)
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(size:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`size`)])
      mockingContext.didInvoke(invocation)
    }
  }
}

/// Create a source-attributed `MockingbirdTestsHost.Tree` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Tree.Type) -> TreeMock.InitializerProxy.Type {
  return TreeMock.InitializerProxy.self
}

/// Create a source-attributed `Fruit` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.Tree.Fruit.Type) -> TreeMock.FruitMock.InitializerProxy.Type {
  return TreeMock.FruitMock.InitializerProxy.self
}

// MARK: - Mocked TupleTypes

public final class TupleTypesMock: MockingbirdTestsHost.TupleTypes, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TupleTypesMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `anotherVariable`

  public var anotherVariable: (Foundation.URL, Foundation.NSObject) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (Foundation.URL, Foundation.NSObject))()
    }
  }

  public func getAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "anotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledAnotherVariable`

  public var labeledAnotherVariable: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func getLabeledAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledVariable`

  public var labeledVariable: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)))()
    }
  }

  public func getLabeledVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalAnotherVariable`

  public var optionalAnotherVariable: (Foundation.URL?, Foundation.NSObject?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (Foundation.URL?, Foundation.NSObject?))()
    }
  }

  public func getOptionalAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (Foundation.URL?, Foundation.NSObject?), (Foundation.URL?, Foundation.NSObject?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalLabeledAnotherVariable`

  public var optionalLabeledAnotherVariable: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?))()
    }
  }

  public func getOptionalLabeledAnotherVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledAnotherVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL?, Foundation.NSObject?)?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalLabeledVariable`

  public var optionalLabeledVariable: (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?))()
    }
  }

  public func getOptionalLabeledVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalLabeledVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?), (a: MockingbirdTestsHost.URL?, b: MockingbirdTestsHost.NSObject?, (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `optionalVariable`

  public var optionalVariable: (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?))()
    }
  }

  public func getOptionalVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "optionalVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?), (MockingbirdTestsHost.URL?, MockingbirdTestsHost.NSObject?)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variable`

  public var variable: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))()
    }
  }

  public func getVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: TupleTypesMock, rhs: TupleTypesMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `labeledMethod()`

  public func labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  public func labeledMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod()`

  public func labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  public func labeledMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod()`

  public func labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func labeledMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod()`

  public func labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)))()
    }
  }

  public func labeledMethod() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod() -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethod(param1:param2:)`

  public func labeledMethod(param1: (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), param2: (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func labeledMethod(param1: @escaping @autoclosure () -> (a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), param2: @escaping @autoclosure () -> (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethod(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `labeledMethodWithParameterLabels()`

  public func labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))))()
    }
  }

  public func labeledMethodWithParameterLabels() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "labeledMethodWithParameterLabels() -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))), ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject))) -> ((a: MockingbirdTestsHost.URL, b: MockingbirdTestsHost.NSObject, (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)), (a: Foundation.URL, b: Foundation.NSObject, (Foundation.URL, Foundation.NSObject)))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> (Foundation.URL, Foundation.NSObject) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (Foundation.URL, Foundation.NSObject) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (Foundation.URL, Foundation.NSObject))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> (Foundation.URL, Foundation.NSObject)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (Foundation.URL, Foundation.NSObject), (Foundation.URL, Foundation.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method()`

  public func method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject))()
    }
  }

  public func method() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method() -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject)>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `method(param1:param2:)`

  public func method(param1: (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), param2: (Foundation.URL, Foundation.NSObject)) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func method(param1: @escaping @autoclosure () -> (MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), param2: @escaping @autoclosure () -> (Foundation.URL, Foundation.NSObject)) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(param1:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `methodWithParameterLabels()`

  public func methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) {
      return concreteImplementation()
    } else {
      return (implementation as! () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)))()
    }
  }

  public func methodWithParameterLabels() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "methodWithParameterLabels() -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)), ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject)) -> ((MockingbirdTestsHost.URL, MockingbirdTestsHost.NSObject), (Foundation.URL, Foundation.NSObject))>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.TupleTypes` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TupleTypes.Protocol) -> TupleTypesMock {
  return TupleTypesMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TypealiasedClass

public final class TypealiasedClassMock: MockingbirdTestsHost.TypealiasedClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TypealiasedClassMock, rhs: TypealiasedClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request(callback:)`

  public override func request(callback: IndirectCallback) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> Foundation.NSObject {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(callback:)`

  public override func request(callback: IndirectCallback) -> IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(escapingCallback:)`

  public override func request(escapingCallback: @escaping IndirectCallback) -> IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`escapingCallback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  public func request(escapingCallback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`escapingCallback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.TypealiasedClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TypealiasedClass.Type) -> TypealiasedClassMock {
  return TypealiasedClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked TypealiasedProtocol

public final class TypealiasedProtocolMock: MockingbirdTestsHost.TypealiasedProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TypealiasedProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TypealiasedProtocolMock, rhs: TypealiasedProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `request(callback:)`

  public func request(callback: IndirectCallback) -> Foundation.NSObject {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> Foundation.NSObject {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> Foundation.NSObject)()
    }
  }

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> Foundation.NSObject, Foundation.NSObject> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> Foundation.NSObject", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> Foundation.NSObject, Foundation.NSObject>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(callback:)`

  public func request(callback: IndirectCallback) -> IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<IndirectCallback>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`callback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  public func request(callback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`callback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(callback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `request(escapingCallback:)`

  public func request(escapingCallback: @escaping IndirectCallback) -> IndirectRequestResult {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: [Mockingbird.ArgumentMatcher(`escapingCallback`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping IndirectCallback) -> IndirectRequestResult {
      return concreteImplementation(`escapingCallback`)
    } else {
      return (implementation as! () -> IndirectRequestResult)()
    }
  }

  public func request(escapingCallback: @escaping @autoclosure () -> IndirectCallback) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`escapingCallback`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "request(escapingCallback:) -> IndirectRequestResult", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (@escaping IndirectCallback) -> IndirectRequestResult, IndirectRequestResult>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.TypealiasedProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.TypealiasedProtocol.Protocol) -> TypealiasedProtocolMock {
  return TypealiasedProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked UndefinedArgumentLabels

public final class UndefinedArgumentLabelsMock: MockingbirdTestsHost.UndefinedArgumentLabels, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UndefinedArgumentLabelsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: UndefinedArgumentLabelsMock, rhs: UndefinedArgumentLabelsMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `method(_:_:_:_:)`

  public func method(_ param1: Bool, _ param2: String, _ someParam: Int, _ param4: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`), Mockingbird.ArgumentMatcher(`someParam`), Mockingbird.ArgumentMatcher(`param4`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, String, Int, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`, `someParam`, `param4`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func method(_ param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> String, _ someParam: @escaping @autoclosure () -> Int, _ param4: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, String, Int, Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool, String, Int, Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.UndefinedArgumentLabels` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol) -> UndefinedArgumentLabelsMock {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariablesContainerProtocol

public final class VariablesContainerProtocolMock: MockingbirdTestsHost.VariablesContainerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked `readonlyVariableOverwrittenAsReadwrite`

  public var readonlyVariableOverwrittenAsReadwrite: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getReadonlyVariableOverwrittenAsReadwrite() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: VariablesContainerProtocolMock, rhs: VariablesContainerProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `MockingbirdTestsHost.VariablesContainerProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariablesContainerProtocol.Protocol) -> VariablesContainerProtocolMock {
  return VariablesContainerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariablesContainer

public final class VariablesContainerMock: MockingbirdTestsHost.VariablesContainer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(__file: StaticString = #file, __line: UInt = #line) -> VariablesContainerMock {
      let mock: VariablesContainerMock = VariablesContainerMock()
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `computedMutableVariable`

  override public var computedMutableVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedMutableVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedMutableVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedMutableVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `computedVariableWithDidSetObserver`

  override public var computedVariableWithDidSetObserver: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedVariableWithDidSetObserver() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedVariableWithDidSetObserver(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithDidSetObserver.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `computedVariableWithWillSetObserver`

  override public var computedVariableWithWillSetObserver: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getComputedVariableWithWillSetObserver() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setComputedVariableWithWillSetObserver(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariableWithWillSetObserver.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `computedVariable`

  override public var computedVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
  }

  public func getComputedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `readonlyVariableOverwrittenAsReadwrite`

  override public var readonlyVariableOverwrittenAsReadwrite: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getReadonlyVariableOverwrittenAsReadwrite() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setReadonlyVariableOverwrittenAsReadwrite(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "readonlyVariableOverwrittenAsReadwrite.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `storedVariableWithExplicitType`

  override public var storedVariableWithExplicitType: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithExplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithExplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithExplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `storedVariableWithImplicitType`

  override public var storedVariableWithImplicitType: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getStoredVariableWithImplicitType() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setStoredVariableWithImplicitType(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "storedVariableWithImplicitType.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `uninitializedVariable`

  override public var uninitializedVariable: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getUninitializedVariable() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setUninitializedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "uninitializedVariable.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  public static func ==(lhs: VariablesContainerMock, rhs: VariablesContainerMock) -> Bool {
    return true
  }

  // MARK: Mocked `init()`

  public required override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.VariablesContainer` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariablesContainer.Type) -> VariablesContainerMock.InitializerProxy.Type {
  return VariablesContainerMock.InitializerProxy.self
}

// MARK: - Mocked VariadicClass

public final class VariadicClassMock: MockingbirdTestsHost.VariadicClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: VariadicClassMock, rhs: VariadicClassMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `variadicMethod(objects:param2:)`

  public override func variadicMethod(objects: Bool..., param2: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethod(objects:param2:)`

  public override func variadicMethod(objects: String..., param2: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethodAsFinalParam(param1:objects:)`

  public override func variadicMethodAsFinalParam(param1: Int, objects: String...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicReturningMethod(objects:param2:)`

  public override func variadicReturningMethod(objects: Bool..., param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.VariadicClass` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariadicClass.Type) -> VariadicClassMock {
  return VariadicClassMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariadicProtocol

public final class VariadicProtocolMock: MockingbirdTestsHost.VariadicProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.4.2", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: VariadicProtocolMock, rhs: VariadicProtocolMock) -> Bool {
    return true
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: Bool..., param2: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: String..., param2: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([String], Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: Int, objects: String...) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }
  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int, [String]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: Bool..., param2: Int) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Bool], Int) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `MockingbirdTestsHost.VariadicProtocol` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: MockingbirdTestsHost.VariadicProtocol.Protocol) -> VariadicProtocolMock {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line))
}
