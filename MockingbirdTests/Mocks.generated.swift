//
//  Mocks.generated.swift
//  MockingbirdTestsHost
//
//  Generated by Mockingbird v0.1.3 on 8/28/19.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import MockingbirdTestsHost
import CoreAudio
import CoreData
import CoreFoundation
import CoreImage
import CoreML
import CoreText
import Foundation
import ObjectiveC
import class CoreFoundation.CFArray
import enum CoreText.CTFontUIFontType

private class Synchronized<T> {
  private var internalValue: T
  fileprivate var value: T {
    get {
      lock.wait()
      defer { lock.signal() }
      return internalValue
    }

    set {
      lock.wait()
      defer { lock.signal() }
      internalValue = newValue
    }
  }
  private let lock = DispatchSemaphore(value: 1)

  fileprivate init(_ value: T) {
    self.internalValue = value
  }

  fileprivate func update(_ block: (inout T) throws -> Void) rethrows {
    lock.wait()
    defer { lock.signal() }
    try block(&internalValue)
  }
}

private var genericTypesStaticMocks = Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked ArgumentMatchingProtocol

public final class ArgumentMatchingProtocolMock: MockingbirdTestsHost.ArgumentMatchingProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ArgumentMatchingProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ArgumentMatchingProtocolMock, rhs: ArgumentMatchingProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: StructType?, optionalClassType: ClassType?, optionalEnumType: EnumType?, optionalStringType: String?, optionalBoolType: Bool?, optionalMetaType: ClassType.Type?, optionalAnyType: Any?, optionalAnyObjectType: AnyObject?) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`optionalStructType`), Mockingbird.ArgumentMatcher(`optionalClassType`), Mockingbird.ArgumentMatcher(`optionalEnumType`), Mockingbird.ArgumentMatcher(`optionalStringType`), Mockingbird.ArgumentMatcher(`optionalBoolType`), Mockingbird.ArgumentMatcher(`optionalMetaType`), Mockingbird.ArgumentMatcher(`optionalAnyType`), Mockingbird.ArgumentMatcher(`optionalAnyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (StructType?, ClassType?, EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool {
      return concreteImplementation(`optionalStructType`, `optionalClassType`, `optionalEnumType`, `optionalStringType`, `optionalBoolType`, `optionalMetaType`, `optionalAnyType`, `optionalAnyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: @escaping @autoclosure () -> StructType?, optionalClassType: @escaping @autoclosure () -> ClassType?, optionalEnumType: @escaping @autoclosure () -> EnumType?, optionalStringType: @escaping @autoclosure () -> String?, optionalBoolType: @escaping @autoclosure () -> Bool?, optionalMetaType: @escaping @autoclosure () -> ClassType.Type?, optionalAnyType: @escaping @autoclosure () -> Any?, optionalAnyObjectType: @escaping @autoclosure () -> AnyObject?) -> Mockingbird.Stubbable<(StructType?, ClassType?, EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`optionalStructType`), Mockingbird.resolve(`optionalClassType`), Mockingbird.resolve(`optionalEnumType`), Mockingbird.resolve(`optionalStringType`), Mockingbird.resolve(`optionalBoolType`), Mockingbird.resolve(`optionalMetaType`), Mockingbird.resolve(`optionalAnyType`), Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(StructType?, ClassType?, EnumType?, String?, Bool?, ClassType.Type?, Any?, AnyObject?) -> Bool, Bool>()
  }

  // MARK: Verifiable `method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:)`

  public func method(optionalStructType: @escaping @autoclosure () -> StructType?, optionalClassType: @escaping @autoclosure () -> ClassType?, optionalEnumType: @escaping @autoclosure () -> EnumType?, optionalStringType: @escaping @autoclosure () -> String?, optionalBoolType: @escaping @autoclosure () -> Bool?, optionalMetaType: @escaping @autoclosure () -> ClassType.Type?, optionalAnyType: @escaping @autoclosure () -> Any?, optionalAnyObjectType: @escaping @autoclosure () -> AnyObject?) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`optionalStructType`), Mockingbird.resolve(`optionalClassType`), Mockingbird.resolve(`optionalEnumType`), Mockingbird.resolve(`optionalStringType`), Mockingbird.resolve(`optionalBoolType`), Mockingbird.resolve(`optionalMetaType`), Mockingbird.resolve(`optionalAnyType`), Mockingbird.resolve(`optionalAnyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(optionalStructType:optionalClassType:optionalEnumType:optionalStringType:optionalBoolType:optionalMetaType:optionalAnyType:optionalAnyObjectType:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: StructType, classType: ClassType, enumType: EnumType, stringType: String, boolType: Bool, metaType: ClassType.Type, anyType: Any, anyObjectType: AnyObject) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`structType`), Mockingbird.ArgumentMatcher(`classType`), Mockingbird.ArgumentMatcher(`enumType`), Mockingbird.ArgumentMatcher(`stringType`), Mockingbird.ArgumentMatcher(`boolType`), Mockingbird.ArgumentMatcher(`metaType`), Mockingbird.ArgumentMatcher(`anyType`), Mockingbird.ArgumentMatcher(`anyObjectType`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (StructType, ClassType, EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool {
      return concreteImplementation(`structType`, `classType`, `enumType`, `stringType`, `boolType`, `metaType`, `anyType`, `anyObjectType`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: @escaping @autoclosure () -> StructType, classType: @escaping @autoclosure () -> ClassType, enumType: @escaping @autoclosure () -> EnumType, stringType: @escaping @autoclosure () -> String, boolType: @escaping @autoclosure () -> Bool, metaType: @escaping @autoclosure () -> ClassType.Type, anyType: @escaping @autoclosure () -> Any, anyObjectType: @escaping @autoclosure () -> AnyObject) -> Mockingbird.Stubbable<(StructType, ClassType, EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`structType`), Mockingbird.resolve(`classType`), Mockingbird.resolve(`enumType`), Mockingbird.resolve(`stringType`), Mockingbird.resolve(`boolType`), Mockingbird.resolve(`metaType`), Mockingbird.resolve(`anyType`), Mockingbird.resolve(`anyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(StructType, ClassType, EnumType, String, Bool, ClassType.Type, Any, AnyObject) -> Bool, Bool>()
  }

  // MARK: Verifiable `method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:)`

  public func method(structType: @escaping @autoclosure () -> StructType, classType: @escaping @autoclosure () -> ClassType, enumType: @escaping @autoclosure () -> EnumType, stringType: @escaping @autoclosure () -> String, boolType: @escaping @autoclosure () -> Bool, metaType: @escaping @autoclosure () -> ClassType.Type, anyType: @escaping @autoclosure () -> Any, anyObjectType: @escaping @autoclosure () -> AnyObject) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`structType`), Mockingbird.resolve(`classType`), Mockingbird.resolve(`enumType`), Mockingbird.resolve(`stringType`), Mockingbird.resolve(`boolType`), Mockingbird.resolve(`metaType`), Mockingbird.resolve(`anyType`), Mockingbird.resolve(`anyObjectType`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(structType:classType:enumType:stringType:boolType:metaType:anyType:anyObjectType:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }
}

/// Create a source-attributed `ArgumentMatchingProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.ArgumentMatchingProtocol.Protocol) -> ArgumentMatchingProtocolMock {
  return ArgumentMatchingProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeGenericImplementer

public final class AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>: MockingbirdTestsHost.AssociatedTypeGenericImplementer<EquatableType, S>, Mockingbird.Mock where S.Element == EquatableType {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(S.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeGenericImplementerMock<EquatableType: Equatable, S: Sequence>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeGenericImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeGenericImplementerMock, rhs: AssociatedTypeGenericImplementerMock) -> Bool {
    return true
  }

  // MARK: Mockable `methodUsingEquatableType(equatable:)`

  public override func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public override func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>()
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<EquatableType>()
  }

  // MARK: Mockable `methodUsingHashableType(hashable:)`

  public override func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Stubbable<(HashableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(HashableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked AssociatedTypeImplementerProtocol

public final class AssociatedTypeImplementerProtocolMock: MockingbirdTestsHost.AssociatedTypeImplementerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerProtocolMock, rhs: AssociatedTypeImplementerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Bool, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T.HashableType> where T.EquatableType == Bool, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<T.HashableType>()
  }

  // MARK: Mockable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: T) -> T.HashableType where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (T) -> T.HashableType {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> T.HashableType)()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> T.HashableType, T.HashableType>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<T.HashableType> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> T.HashableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<T.HashableType>()
  }

  // MARK: Mockable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> Void, Void>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `AssociatedTypeImplementerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.AssociatedTypeImplementerProtocol.Protocol) -> AssociatedTypeImplementerProtocolMock {
  return AssociatedTypeImplementerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AssociatedTypeImplementer

public final class AssociatedTypeImplementerMock: MockingbirdTestsHost.AssociatedTypeImplementer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeImplementerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeImplementerMock, rhs: AssociatedTypeImplementerMock) -> Bool {
    return true
  }

  // MARK: Mockable `request(object:)`

  public override func request<T: AssociatedTypeProtocol>(object: T) -> Void where T.EquatableType == Int, T.HashableType == String {
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (T) -> Void {
      concreteImplementation(`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Stubbable<(T) -> Void, Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(T) -> Void, Void>()
  }

  // MARK: Verifiable `request(object:)`

  public func request<T: AssociatedTypeProtocol>(object: @escaping @autoclosure () -> T) -> Mockingbird.Mockable<Void> where T.EquatableType == Int, T.HashableType == String {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "request(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked AssociatedTypeProtocol

public final class AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>: MockingbirdTestsHost.AssociatedTypeProtocol, Mockingbird.Mock {
  static var staticMock: Mockingbird.StaticMock {
    let runtimeGenericTypeNames = ["\(EquatableType.self)", "\(HashableType.self)"].joined(separator: ",")
    let staticMockIdentifier = "AssociatedTypeProtocolMock<EquatableType: Equatable, HashableType: Hashable>," + runtimeGenericTypeNames
    if let staticMock = genericTypesStaticMocks.value[staticMockIdentifier] {
      return staticMock
    }
    let staticMock = Mockingbird.StaticMock()
    genericTypesStaticMocks.update { $0[staticMockIdentifier] = staticMock }
    return staticMock
  }
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AssociatedTypeProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: AssociatedTypeProtocolMock, rhs: AssociatedTypeProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: EquatableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (EquatableType) -> Void {
      concreteImplementation(`equatable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingEquatableType(equatable:)`

  public func methodUsingEquatableType(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableType(equatable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: EquatableType) -> EquatableType {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: [Mockingbird.ArgumentMatcher(`equatable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (EquatableType) -> EquatableType {
      return concreteImplementation(`equatable`)
    } else {
      return (implementation as! () -> EquatableType)()
    }
  }

  // MARK: Stubbable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(EquatableType) -> EquatableType, EquatableType>()
  }

  // MARK: Verifiable `methodUsingEquatableTypeWithReturn(equatable:)`

  public func methodUsingEquatableTypeWithReturn(equatable: @escaping @autoclosure () -> EquatableType) -> Mockingbird.Mockable<EquatableType> {
    let arguments = [Mockingbird.resolve(`equatable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingEquatableTypeWithReturn(equatable:) -> EquatableType", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<EquatableType>()
  }

  // MARK: Mockable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: HashableType) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hashable`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (HashableType) -> Void {
      concreteImplementation(`hashable`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Stubbable<(HashableType) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(HashableType) -> Void, Void>()
  }

  // MARK: Verifiable `methodUsingHashableType(hashable:)`

  public func methodUsingHashableType(hashable: @escaping @autoclosure () -> HashableType) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`hashable`)]
    let invocation = Mockingbird.Invocation(selectorName: "methodUsingHashableType(hashable:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `AssociatedTypeProtocol<EquatableType, HashableType>` mock.
public func mockProtocol<T: MockingbirdTestsHost.AssociatedTypeProtocol, EquatableType: Equatable, HashableType: Hashable>(file: StaticString = #file, line: UInt = #line, _ protocolType: T.Type) -> AssociatedTypeProtocolMock<EquatableType, HashableType> {
  return AssociatedTypeProtocolMock<EquatableType, HashableType>(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ChildProtocol

public final class ChildProtocolMock: MockingbirdTestsHost.ChildProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `childInstanceVariable`

  public var childInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childInstanceVariable`

  public func getChildInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childInstanceVariable`

  public func getChildInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setChildInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childPrivateSetterInstanceVariable`

  public var childPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childPrivateSetterInstanceVariable`

  public func getChildPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setChildPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childPrivateSetterStaticVariable`

  public class var childPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childPrivateSetterStaticVariable`

  public class func getChildPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setChildPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childStaticVariable`

  public class var childStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childStaticVariable`

  public class func getChildStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childStaticVariable`

  public class func getChildStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setChildStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ChildProtocolMock, rhs: ChildProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedStaticMethod(param1:_:)`

  public static func childParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialStaticMethod()`

  public static func childTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `ChildProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.ChildProtocol.Protocol) -> ChildProtocolMock {
  return ChildProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Child

public final class ChildMock: MockingbirdTestsHost.Child, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ChildMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `childClassVariable`

  override public class var childClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childClassVariable`

  public class func getChildClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childClassVariable`

  public class func getChildClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setChildClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childComputedInstanceVariable`

  override public var childComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `childComputedInstanceVariable`

  public func getChildComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setChildComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "childComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ChildMock, rhs: ChildMock) -> Bool {
    return true
  }

  // MARK: Mockable `childParameterizedClassMethod(param1:_:)`

  public override static func childParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedClassMethod(param1:_:)`

  public static func childParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childParameterizedInstanceMethod(param1:_:)`

  public override func childParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `childParameterizedInstanceMethod(param1:_:)`

  public func childParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "childParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `childTrivialClassMethod()`

  public override static func childTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialClassMethod()`

  public static func childTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `childTrivialInstanceMethod()`

  public override func childTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `childTrivialInstanceMethod()`

  public func childTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "childTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked ClassType

public final class ClassTypeMock: MockingbirdTestsHost.ClassType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClassTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ClassTypeMock, rhs: ClassTypeMock) -> Bool {
    return true
  }
}

// MARK: - Mocked ClosureParametersProtocol

public final class ClosureParametersProtocolMock: MockingbirdTestsHost.ClosureParametersProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClosureParametersProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ClosureParametersProtocolMock, rhs: ClosureParametersProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @autoclosure () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(@autoclosure () -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@autoclosure () -> Void) -> Bool, Bool>()
  }

  // MARK: Verifiable `autoclosureTrivialClosure(block:)`

  public func autoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @autoclosure () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(@autoclosure () -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@autoclosure () -> Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `autoclosureTrivialReturningClosure(block:)`

  public func autoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "autoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Void) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(@escaping @autoclosure () -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@escaping @autoclosure () -> Void) -> Bool, Bool>()
  }

  // MARK: Verifiable `escapingAutoclosureTrivialClosure(block:)`

  public func escapingAutoclosureTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping @autoclosure () -> Bool) -> Bool {
      return concreteImplementation(`block`())
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(@escaping @autoclosure () -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@escaping @autoclosure () -> Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `escapingAutoclosureTrivialReturningClosure(block:)`

  public func escapingAutoclosureTrivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingAutoclosureTrivialReturningClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping (Bool) -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Stubbable<(@escaping (Bool) -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@escaping (Bool) -> Void) -> Bool, Bool>()
  }

  // MARK: Verifiable `escapingParameterizedClosure(block:)`

  public func escapingParameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping (Bool) -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping (Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Stubbable<(@escaping (Bool) -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@escaping (Bool) -> Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `escapingParameterizedReturningClosure(block:)`

  public func escapingParameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingParameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(@escaping () -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@escaping () -> Void) -> Bool, Bool>()
  }

  // MARK: Verifiable `escapingTrivialClosure(block:)`

  public func escapingTrivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`block`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (@escaping () -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(@escaping () -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(@escaping () -> Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `escapingTrivialReturningVoidClosure(block:)`

  public func escapingTrivialReturningVoidClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "escapingTrivialReturningVoidClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parameterizedClosure(block:)`

  public func parameterizedClosure(block: (Bool) -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedClosure(block:)`

  public func parameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Stubbable<((Bool) -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<((Bool) -> Void) -> Bool, Bool>()
  }

  // MARK: Verifiable `parameterizedClosure(block:)`

  public func parameterizedClosure(block: @escaping @autoclosure () -> (Bool) -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: (Bool) -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ((Bool) -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Stubbable<((Bool) -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<((Bool) -> Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `parameterizedReturningClosure(block:)`

  public func parameterizedReturningClosure(block: @escaping @autoclosure () -> (Bool) -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `trivialClosure(block:)`

  public func trivialClosure(block: () -> Void) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Void) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `trivialClosure(block:)`

  public func trivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Stubbable<(() -> Void) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(() -> Void) -> Bool, Bool>()
  }

  // MARK: Verifiable `trivialClosure(block:)`

  public func trivialClosure(block: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: () -> Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(nil)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (() -> Bool) -> Bool {
      return concreteImplementation(`block`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Stubbable<(() -> Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(() -> Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `trivialReturningClosure(block:)`

  public func trivialReturningClosure(block: @escaping @autoclosure () -> () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`block`)]
    let invocation = Mockingbird.Invocation(selectorName: "trivialReturningClosure(block:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }
}

/// Create a source-attributed `ClosureParametersProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.ClosureParametersProtocol.Protocol) -> ClosureParametersProtocolMock {
  return ClosureParametersProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ConvenienceInitializerClass

public final class ConvenienceInitializerClassMock: MockingbirdTestsHost.ConvenienceInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConvenienceInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ConvenienceInitializerClassMock, rhs: ConvenienceInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public override init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked EmptyInitializerClass

public final class EmptyInitializerClassMock: MockingbirdTestsHost.EmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: EmptyInitializerClassMock, rhs: EmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked EmptyInitializerProtocol

public final class EmptyInitializerProtocolMock: MockingbirdTestsHost.EmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      EmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: EmptyInitializerProtocolMock, rhs: EmptyInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public init() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

/// Create a source-attributed `EmptyInitializerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.EmptyInitializerProtocol.Protocol) -> EmptyInitializerProtocolMock {
  return EmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ExtendableProtocol

public final class ExtendableProtocolMock: MockingbirdTestsHost.ExtendableProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ExtendableProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `anotherExtendedVariable`

  public var anotherExtendedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `anotherExtendedVariable`

  public func getAnotherExtendedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setAnotherExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `anotherExtendedVariable`

  public func getAnotherExtendedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setAnotherExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "anotherExtendedVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `baseVariable`

  public var baseVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `extendedVariable`

  public var extendedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `extendedVariable`

  public func getExtendedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `extendedVariable`

  public func getExtendedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setExtendedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "extendedVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ExtendableProtocolMock, rhs: ExtendableProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `anotherTrivialExtendedMethod()`

  public func anotherTrivialExtendedMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "anotherTrivialExtendedMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: Bool) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`param1`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parameterizedExtendedMethod(param1:)`

  public func parameterizedExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedExtendedMethod(param1:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`param1`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `parameterizedReturningExtendedMethod(param1:)`

  public func parameterizedReturningExtendedMethod(param1: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedReturningExtendedMethod(param1:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `trivialExtendedMethod()`

  public func trivialExtendedMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialExtendedMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `ExtendableProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.ExtendableProtocol.Protocol) -> ExtendableProtocolMock {
  return ExtendableProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableEmptyInitializerClass

public final class FailableEmptyInitializerClassMock: MockingbirdTestsHost.FailableEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableEmptyInitializerClassMock, rhs: FailableEmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public override init?() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked FailableEmptyInitializerProtocol

public final class FailableEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableEmptyInitializerProtocolMock, rhs: FailableEmptyInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public init?() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

/// Create a source-attributed `FailableEmptyInitializerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.FailableEmptyInitializerProtocol.Protocol) -> FailableEmptyInitializerProtocolMock {
  return FailableEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableParameterizedInitializerClass

public final class FailableParameterizedInitializerClassMock: MockingbirdTestsHost.FailableParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableParameterizedInitializerClassMock, rhs: FailableParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public override init?(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked FailableParameterizedInitializerProtocol

public final class FailableParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableParameterizedInitializerProtocolMock, rhs: FailableParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init(param1:param2:)`

  public init?(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

/// Create a source-attributed `FailableParameterizedInitializerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.FailableParameterizedInitializerProtocol.Protocol) -> FailableParameterizedInitializerProtocolMock {
  return FailableParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerClass

public final class FailableUnwrappedEmptyInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedEmptyInitializerClassMock, rhs: FailableUnwrappedEmptyInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public override init!() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked FailableUnwrappedEmptyInitializerProtocol

public final class FailableUnwrappedEmptyInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedEmptyInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedEmptyInitializerProtocolMock, rhs: FailableUnwrappedEmptyInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init()`

  public init!() {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

/// Create a source-attributed `FailableUnwrappedEmptyInitializerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.FailableUnwrappedEmptyInitializerProtocol.Protocol) -> FailableUnwrappedEmptyInitializerProtocolMock {
  return FailableUnwrappedEmptyInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerClass

public final class FailableUnwrappedParameterizedInitializerClassMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedParameterizedInitializerClassMock, rhs: FailableUnwrappedParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public override init!(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked FailableUnwrappedParameterizedInitializerProtocol

public final class FailableUnwrappedParameterizedInitializerProtocolMock: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      FailableUnwrappedParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: FailableUnwrappedParameterizedInitializerProtocolMock, rhs: FailableUnwrappedParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init(param1:param2:)`

  public init!(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

/// Create a source-attributed `FailableUnwrappedParameterizedInitializerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.FailableUnwrappedParameterizedInitializerProtocol.Protocol) -> FailableUnwrappedParameterizedInitializerProtocolMock {
  return FailableUnwrappedParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked GrandparentProtocol

public final class GrandparentProtocolMock: MockingbirdTestsHost.GrandparentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: GrandparentProtocolMock, rhs: GrandparentProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `GrandparentProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.GrandparentProtocol.Protocol) -> GrandparentProtocolMock {
  return GrandparentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Grandparent

public final class GrandparentMock: MockingbirdTestsHost.Grandparent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      GrandparentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: GrandparentMock, rhs: GrandparentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked InoutClass

public final class InoutClassMock: MockingbirdTestsHost.InoutClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutClassMock, rhs: InoutClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `parameterizedMethod(object:)`

  public override func parameterizedMethod(object: inout String) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(inout String) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(inout String) -> Void, Void>()
  }

  // MARK: Verifiable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked InoutProtocol

public final class InoutProtocolMock: MockingbirdTestsHost.InoutProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      InoutProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: InoutProtocolMock, rhs: InoutProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: inout String) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (inout String) -> Void {
      concreteImplementation(&`object`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Stubbable<(inout String) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(inout String) -> Void, Void>()
  }

  // MARK: Verifiable `parameterizedMethod(object:)`

  public func parameterizedMethod(object: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`object`)]
    let invocation = Mockingbird.Invocation(selectorName: "parameterizedMethod(object:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `InoutProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.InoutProtocol.Protocol) -> InoutProtocolMock {
  return InoutProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked NonExtendableClass

public final class NonExtendableClassMock: MockingbirdTestsHost.NonExtendableClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      NonExtendableClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `baseVariable`

  override public var baseVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `baseVariable`

  public func getBaseVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setBaseVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "baseVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: NonExtendableClassMock, rhs: NonExtendableClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `trivialBaseMethod()`

  public override func trivialBaseMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `trivialBaseMethod()`

  public func trivialBaseMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "trivialBaseMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked OverloadedMethodsClass

public final class OverloadedMethodsClassMock: MockingbirdTestsHost.OverloadedMethodsClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: OverloadedMethodsClassMock, rhs: OverloadedMethodsClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public override func overloadedParameters(param1: Bool, param2: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public override func overloadedParameters(param1: Int, param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Int, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Int, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `overloadedReturnType()`

  public override func overloadedReturnType() -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Bool, Bool>()
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `overloadedReturnType()`

  public override func overloadedReturnType() -> Int {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Int, Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Int, Int>()
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Int>()
  }
}

// MARK: - Mocked OverloadedMethodsProtocol

public final class OverloadedMethodsProtocolMock: MockingbirdTestsHost.OverloadedMethodsProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      OverloadedMethodsProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: OverloadedMethodsProtocolMock, rhs: OverloadedMethodsProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: Bool, param2: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Bool, param2: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: Int, param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Int, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Int, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Int, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `overloadedParameters(param1:param2:)`

  public func overloadedParameters(param1: @escaping @autoclosure () -> Int, param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "overloadedParameters(param1:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `overloadedReturnType()`

  public func overloadedReturnType() -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Bool, Bool>()
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Bool", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `overloadedReturnType()`

  public func overloadedReturnType() -> Int {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Int {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Int)()
    }
  }

  // MARK: Stubbable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Stubbable<() -> Int, Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Int, Int>()
  }

  // MARK: Verifiable `overloadedReturnType()`

  public func overloadedReturnType() -> Mockingbird.Mockable<Int> {
    let invocation = Mockingbird.Invocation(selectorName: "overloadedReturnType() -> Int", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Int>()
  }
}

/// Create a source-attributed `OverloadedMethodsProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.OverloadedMethodsProtocol.Protocol) -> OverloadedMethodsProtocolMock {
  return OverloadedMethodsProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParameterizedInitializerClass

public final class ParameterizedInitializerClassMock: MockingbirdTestsHost.ParameterizedInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ParameterizedInitializerClassMock, rhs: ParameterizedInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public override init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked ParameterizedInitializerProtocol

public final class ParameterizedInitializerProtocolMock: MockingbirdTestsHost.ParameterizedInitializerProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParameterizedInitializerProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: ParameterizedInitializerProtocolMock, rhs: ParameterizedInitializerProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `init(param1:param2:)`

  public init(param1: Bool, param2: Int) {
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

/// Create a source-attributed `ParameterizedInitializerProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.ParameterizedInitializerProtocol.Protocol) -> ParameterizedInitializerProtocolMock {
  return ParameterizedInitializerProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ParentProtocol

public final class ParentProtocolMock: MockingbirdTestsHost.ParentProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentInstanceVariable`

  public var grandparentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentInstanceVariable`

  public func getGrandparentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterInstanceVariable`

  public var grandparentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterInstanceVariable`

  public func getGrandparentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentPrivateSetterStaticVariable`

  public class var grandparentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentPrivateSetterStaticVariable`

  public class func getGrandparentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentStaticVariable`

  public class var grandparentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentStaticVariable`

  public class func getGrandparentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentInstanceVariable`

  public var parentInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentInstanceVariable`

  public func getParentInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterInstanceVariable`

  public var parentPrivateSetterInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterInstanceVariable`

  public func getParentPrivateSetterInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentPrivateSetterInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentPrivateSetterStaticVariable`

  public class var parentPrivateSetterStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentPrivateSetterStaticVariable`

  public class func getParentPrivateSetterStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentPrivateSetterStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentPrivateSetterStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentStaticVariable`

  public class var parentStaticVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentStaticVariable`

  public class func getParentStaticVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentStaticVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentStaticVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ParentProtocolMock, rhs: ParentProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedStaticMethod(param1:_:)`

  public static func grandparentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialStaticMethod()`

  public static func grandparentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedStaticMethod(param1:_:)`

  public static func parentParameterizedStaticMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedStaticMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialStaticMethod()`

  public static func parentTrivialStaticMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialStaticMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

/// Create a source-attributed `ParentProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.ParentProtocol.Protocol) -> ParentProtocolMock {
  return ParentProtocolMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Parent

public final class ParentMock: MockingbirdTestsHost.Parent, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ParentMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `grandparentClassVariable`

  override public class var grandparentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentClassVariable`

  public class func getGrandparentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setGrandparentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentComputedInstanceVariable`

  override public var grandparentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `grandparentComputedInstanceVariable`

  public func getGrandparentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setGrandparentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentClassVariable`

  override public class var parentClassVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
      staticMock.mockingContext.didInvoke(invocation)
      return (staticMock.stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: [ArgumentMatcher(newValue)])
      staticMock.mockingContext.didInvoke(invocation)
      let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentClassVariable`

  public class func getParentClassVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public class func setParentClassVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentClassVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentComputedInstanceVariable`

  override public var parentComputedInstanceVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `parentComputedInstanceVariable`

  public func getParentComputedInstanceVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setParentComputedInstanceVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "parentComputedInstanceVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: ParentMock, rhs: ParentMock) -> Bool {
    return true
  }

  // MARK: Mockable `grandparentParameterizedClassMethod(param1:_:)`

  public override static func grandparentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedClassMethod(param1:_:)`

  public static func grandparentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentParameterizedInstanceMethod(param1:_:)`

  public override func grandparentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `grandparentParameterizedInstanceMethod(param1:_:)`

  public func grandparentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "grandparentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `grandparentTrivialClassMethod()`

  public override static func grandparentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialClassMethod()`

  public static func grandparentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `grandparentTrivialInstanceMethod()`

  public override func grandparentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `grandparentTrivialInstanceMethod()`

  public func grandparentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "grandparentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentParameterizedClassMethod(param1:_:)`

  public override static func parentParameterizedClassMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedClassMethod(param1:_:)`

  public static func parentParameterizedClassMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedClassMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentParameterizedInstanceMethod(param1:_:)`

  public override func parentParameterizedInstanceMethod(param1: Bool, _ param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, Int) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `parentParameterizedInstanceMethod(param1:_:)`

  public func parentParameterizedInstanceMethod(param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "parentParameterizedInstanceMethod(param1:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: Mockable `parentTrivialClassMethod()`

  public override static func parentTrivialClassMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    staticMock.mockingContext.didInvoke(invocation)
    let implementation = staticMock.stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { staticMock.stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialClassMethod()`

  public static func parentTrivialClassMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialClassMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(staticMock.mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `parentTrivialInstanceMethod()`

  public override func parentTrivialInstanceMethod() -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Stubbable<() -> Void, Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<() -> Void, Void>()
  }

  // MARK: Verifiable `parentTrivialInstanceMethod()`

  public func parentTrivialInstanceMethod() -> Mockingbird.Mockable<Void> {
    let invocation = Mockingbird.Invocation(selectorName: "parentTrivialInstanceMethod() -> Void", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }
}

// MARK: - Mocked RequiredInitializerClass

public final class RequiredInitializerClassMock: MockingbirdTestsHost.RequiredInitializerClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RequiredInitializerClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: RequiredInitializerClassMock, rhs: RequiredInitializerClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `init(param1:param2:)`

  public required init(param1: Bool, param2: Int) {
    super.init(param1: `param1`, param2: `param2`)
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init(param1:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool, Int) -> Void {
      concreteImplementation(`param1`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked TopLevelType

public final class TopLevelTypeMock: MockingbirdTestsHost.TopLevelType, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      TopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: TopLevelTypeMock, rhs: TopLevelTypeMock) -> Bool {
    return true
  }

  // MARK: Mockable `topLevelMethod(param1:param2:)`

  public override func topLevelMethod(param1: SecondLevelType, param2: SecondLevelType.ThirdLevelType) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool {
      return concreteImplementation(`param1`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `topLevelMethod(param1:param2:)`

  public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool>()
  }

  // MARK: Verifiable `topLevelMethod(param1:param2:)`

  public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  // MARK: - Mocked SecondLevelType
  
  public final class SecondLevelTypeMock: SecondLevelType, Mockingbird.Mock {
    static let staticMock = Mockingbird.StaticMock()
    public let mockingContext = Mockingbird.MockingContext()
    public let stubbingContext = Mockingbird.StubbingContext()
    public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
    public var sourceLocation: Mockingbird.SourceLocation? {
      get { return stubbingContext.sourceLocation }
      set {
        stubbingContext.sourceLocation = newValue
        SecondLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
      }
    }
  
    public static func ==(lhs: SecondLevelTypeMock, rhs: SecondLevelTypeMock) -> Bool {
      return true
    }
  
    // MARK: Mockable `secondLevelMethod(param1:param2:)`
  
    public override func secondLevelMethod(param1: TopLevelType, param2: ThirdLevelType) -> Bool {
      let invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: false)
      if let concreteImplementation = implementation as? (TopLevelType, ThirdLevelType) -> Bool {
        return concreteImplementation(`param1`, `param2`)
      } else {
        return (implementation as! () -> Bool)()
      }
    }
  
    // MARK: Stubbable `secondLevelMethod(param1:param2:)`
  
    public func secondLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> ThirdLevelType) -> Mockingbird.Stubbable<(TopLevelType, ThirdLevelType) -> Bool, Bool> {
      let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: arguments)
      if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
      return Mockingbird.Stubbable<(TopLevelType, ThirdLevelType) -> Bool, Bool>()
    }
  
    // MARK: Verifiable `secondLevelMethod(param1:param2:)`
  
    public func secondLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> ThirdLevelType) -> Mockingbird.Mockable<Bool> {
      let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
      let invocation = Mockingbird.Invocation(selectorName: "secondLevelMethod(param1:param2:) -> Bool", arguments: arguments)
      if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
      return Mockingbird.Mockable<Bool>()
    }
  
    // MARK: - Mocked ThirdLevelInheritingTopLevelType
    
    public final class ThirdLevelInheritingTopLevelTypeMock: ThirdLevelInheritingTopLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingTopLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingTopLevelTypeMock, rhs: ThirdLevelInheritingTopLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> Bool", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Stubbable<() -> Bool, Bool> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> Bool", arguments: [])
        if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
        return Mockingbird.Stubbable<() -> Bool, Bool>()
      }
    
      // MARK: Verifiable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<Bool> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> Bool", arguments: [])
        if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
        return Mockingbird.Mockable<Bool>()
      }
    
      // MARK: Mockable `topLevelMethod(param1:param2:)`
    
      public override func topLevelMethod(param1: SecondLevelType, param2: SecondLevelType.ThirdLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `topLevelMethod(param1:param2:)`
    
      public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
        return Mockingbird.Stubbable<(SecondLevelType, SecondLevelType.ThirdLevelType) -> Bool, Bool>()
      }
    
      // MARK: Verifiable `topLevelMethod(param1:param2:)`
    
      public func topLevelMethod(param1: @escaping @autoclosure () -> SecondLevelType, param2: @escaping @autoclosure () -> SecondLevelType.ThirdLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "topLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
        return Mockingbird.Mockable<Bool>()
      }
    }
  
    // MARK: - Mocked ThirdLevelInheritingThirdLevelType
    
    public final class ThirdLevelInheritingThirdLevelTypeMock: ThirdLevelInheritingThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelInheritingThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelInheritingThirdLevelTypeMock, rhs: ThirdLevelInheritingThirdLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelInheritingMethod()`
    
      public override func thirdLevelInheritingMethod() -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> Bool", arguments: [])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? () -> Bool {
          return concreteImplementation()
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Stubbable<() -> Bool, Bool> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> Bool", arguments: [])
        if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
        return Mockingbird.Stubbable<() -> Bool, Bool>()
      }
    
      // MARK: Verifiable `thirdLevelInheritingMethod()`
    
      public func thirdLevelInheritingMethod() -> Mockingbird.Mockable<Bool> {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelInheritingMethod() -> Bool", arguments: [])
        if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
        return Mockingbird.Mockable<Bool>()
      }
    
      // MARK: Mockable `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
        return Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool>()
      }
    
      // MARK: Verifiable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
        return Mockingbird.Mockable<Bool>()
      }
    }
  
    // MARK: - Mocked ThirdLevelType
    
    public final class ThirdLevelTypeMock: ThirdLevelType, Mockingbird.Mock {
      static let staticMock = Mockingbird.StaticMock()
      public let mockingContext = Mockingbird.MockingContext()
      public let stubbingContext = Mockingbird.StubbingContext()
      public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
      public var sourceLocation: Mockingbird.SourceLocation? {
        get { return stubbingContext.sourceLocation }
        set {
          stubbingContext.sourceLocation = newValue
          ThirdLevelTypeMock.staticMock.stubbingContext.sourceLocation = newValue
        }
      }
    
      public static func ==(lhs: ThirdLevelTypeMock, rhs: ThirdLevelTypeMock) -> Bool {
        return true
      }
    
      // MARK: Mockable `thirdLevelMethod(param1:param2:)`
    
      public override func thirdLevelMethod(param1: TopLevelType, param2: SecondLevelType) -> Bool {
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`)])
        mockingContext.didInvoke(invocation)
        let implementation = stubbingContext.implementation(for: invocation, optional: false)
        if let concreteImplementation = implementation as? (TopLevelType, SecondLevelType) -> Bool {
          return concreteImplementation(`param1`, `param2`)
        } else {
          return (implementation as! () -> Bool)()
        }
      }
    
      // MARK: Stubbable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
        return Mockingbird.Stubbable<(TopLevelType, SecondLevelType) -> Bool, Bool>()
      }
    
      // MARK: Verifiable `thirdLevelMethod(param1:param2:)`
    
      public func thirdLevelMethod(param1: @escaping @autoclosure () -> TopLevelType, param2: @escaping @autoclosure () -> SecondLevelType) -> Mockingbird.Mockable<Bool> {
        let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`)]
        let invocation = Mockingbird.Invocation(selectorName: "thirdLevelMethod(param1:param2:) -> Bool", arguments: arguments)
        if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
        return Mockingbird.Mockable<Bool>()
      }
    }
  }
}

// MARK: - Mocked UndefinedArgumentLabels

public final class UndefinedArgumentLabelsMock: MockingbirdTestsHost.UndefinedArgumentLabels, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      UndefinedArgumentLabelsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: UndefinedArgumentLabelsMock, rhs: UndefinedArgumentLabelsMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `method(_:_:_:_:)`

  public func method(_ param1: Bool, _ param2: String, _ someParam: Int, _ param4: Bool) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`param2`), Mockingbird.ArgumentMatcher(`someParam`), Mockingbird.ArgumentMatcher(`param4`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool, String, Int, Bool) -> Bool {
      return concreteImplementation(`param1`, `param2`, `someParam`, `param4`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `method(_:_:_:_:)`

  public func method(_ param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> String, _ someParam: @escaping @autoclosure () -> Int, _ param4: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool, String, Int, Bool) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool, String, Int, Bool) -> Bool, Bool>()
  }

  // MARK: Verifiable `method(_:_:_:_:)`

  public func method(_ param1: @escaping @autoclosure () -> Bool, _ param2: @escaping @autoclosure () -> String, _ someParam: @escaping @autoclosure () -> Int, _ param4: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`param2`), Mockingbird.resolve(`someParam`), Mockingbird.resolve(`param4`)]
    let invocation = Mockingbird.Invocation(selectorName: "method(_:_:_:_:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }
}

/// Create a source-attributed `UndefinedArgumentLabels` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.UndefinedArgumentLabels.Protocol) -> UndefinedArgumentLabelsMock {
  return UndefinedArgumentLabelsMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VariablesContainer

public final class VariablesContainerMock: MockingbirdTestsHost.VariablesContainer, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariablesContainerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mockable `computedVariable`

  override public var computedVariable: Bool {
    get {
      let invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation = Mockingbird.Invocation(selectorName: "computedVariable.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  // MARK: Stubbable `computedVariable`

  public func getComputedVariable() -> Mockingbird.Stubbable<() -> Bool, Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Stubbable<() -> Bool, Bool>()
  }

  public func setComputedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Stubbable<(Bool) -> Void, Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.set", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Bool) -> Void, Void>()
  }

  // MARK: Verifiable `computedVariable`

  public func getComputedVariable() -> Mockingbird.Mockable<Bool> {
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.get", arguments: [])
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func setComputedVariable(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(newValue)]
    let invocation = Mockingbird.Invocation(selectorName: "computedVariable.set", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public static func ==(lhs: VariablesContainerMock, rhs: VariablesContainerMock) -> Bool {
    return true
  }

  // MARK: Mockable `init()`

  public override init() {
    super.init()
    Mockingbird.checkVersion(for: self)
    let invocation = Mockingbird.Invocation(selectorName: "init() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }
}

// MARK: - Mocked VariadicClass

public final class VariadicClassMock: MockingbirdTestsHost.VariadicClass, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicClassMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: VariadicClassMock, rhs: VariadicClassMock) -> Bool {
    return true
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public override func variadicMethod(objects: Bool..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>()
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>()
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public override func variadicMethod(objects: String..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>()
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>()
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `variadicMethodAsFinalParam(param1:objects:)`

  public override func variadicMethodAsFinalParam(param1: Int, objects: String...) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>()
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>()
  }

  // MARK: Verifiable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `variadicReturningMethod(objects:param2:)`

  public override func variadicReturningMethod(objects: Bool..., param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>()
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }
}

// MARK: - Mocked VariadicProtocol

public final class VariadicProtocolMock: MockingbirdTestsHost.VariadicProtocol, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.1.3", "module_name": "MockingbirdTestsHost"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VariadicProtocolMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public static func ==(lhs: VariadicProtocolMock, rhs: VariadicProtocolMock) -> Bool {
    return true
  }

  public init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: Bool..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>()
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Void, Void>()
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public func variadicMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: String..., param2: Int) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([String], Int) -> Void {
      concreteImplementation(`objects`, `param2`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>()
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([String], Int) -> Void, Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([String], Int) -> Void, Void>()
  }

  // MARK: Verifiable `variadicMethod(objects:param2:)`

  public func variadicMethod(objects: @escaping @autoclosure () -> [String], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public func variadicMethod(objects: String..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethod(objects:param2:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: Int, objects: String...) -> Void {
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: [Mockingbird.ArgumentMatcher(`param1`), Mockingbird.ArgumentMatcher(`objects`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int, [String]) -> Void {
      concreteImplementation(`param1`, `objects`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  // MARK: Stubbable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>()
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Stubbable<(Int, [String]) -> Void, Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<(Int, [String]) -> Void, Void>()
  }

  // MARK: Verifiable `variadicMethodAsFinalParam(param1:objects:)`

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: @escaping @autoclosure () -> [String]) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.resolve(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  public func variadicMethodAsFinalParam(param1: @escaping @autoclosure () -> Int, objects: String...) -> Mockingbird.Mockable<Void> {
    let arguments = [Mockingbird.resolve(`param1`), Mockingbird.ArgumentMatcher(`objects`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicMethodAsFinalParam(param1:objects:) -> Void", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Void>()
  }

  // MARK: Mockable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: Bool..., param2: Int) -> Bool {
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.ArgumentMatcher(`param2`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? ([Bool], Int) -> Bool {
      return concreteImplementation(`objects`, `param2`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  // MARK: Stubbable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>()
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let stub = DispatchQueue.currentStub { stubbingContext.swizzle(invocation, with: stub.implementation) }
    return Mockingbird.Stubbable<([Bool], Int) -> Bool, Bool>()
  }

  // MARK: Verifiable `variadicReturningMethod(objects:param2:)`

  public func variadicReturningMethod(objects: @escaping @autoclosure () -> [Bool], param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.resolve(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }

  public func variadicReturningMethod(objects: Bool..., param2: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Bool> {
    let arguments = [Mockingbird.ArgumentMatcher(`objects`), Mockingbird.resolve(`param2`)]
    let invocation = Mockingbird.Invocation(selectorName: "variadicReturningMethod(objects:param2:) -> Bool", arguments: arguments)
    if let expectation = DispatchQueue.currentExpectation { expect(mockingContext, handled: invocation, using: expectation) }
    return Mockingbird.Mockable<Bool>()
  }
}

/// Create a source-attributed `VariadicProtocol` mock.
public func mockProtocol(file: StaticString = #file, line: UInt = #line, _ protocolType: MockingbirdTestsHost.VariadicProtocol.Protocol) -> VariadicProtocolMock {
  return VariadicProtocolMock(sourceLocation: SourceLocation(file, line))
}

